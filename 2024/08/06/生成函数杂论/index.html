<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>生成函数杂论 | joke3579</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="多项式，生成函数，符号化方法，dfinite">
  
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">归档</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="/" id="logo">Dr. Zhow</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-生成函数杂论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/06/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%9D%82%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2024-08-05T23:49:22.000Z" itemprop="datePublished">2024-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      生成函数杂论
    </h1>
  

      </header>
    
    
<div id="article-toc">
    <h2 class="widget-title">Table Of Contents</h2>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E5%B9%82%E7%BA%A7%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">多项式与幂级数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">基础定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">多项式牛顿迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F-$%5Ctext%7Blaurent%7D$%20%E7%BA%A7%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">形式 $\text{Laurent}$ 级数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94"><span class="toc-number">1.4.</span> <span class="toc-text">拉格朗日反演</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">分式分解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%3Cspan-class=%22bd-box%22%3E%3Ch-char%20class=%22bd%20bd-end%22%3E%3Ch-inner%3E%EF%BC%88%3C/h-inner%3E%3C/h-char%3E%3C/span%3E$%5Cunderline%7B%5Ctextbf%7Bg%7D%7D%5Ctext%7Benerating%7D%20%5C%20%5Cunderline%7B%5Ctextbf%7Bf%7D%7D%5Ctext%7Bunction%7D,%20%5C%20%5Ctext%7Bgf%7D$%3Cspan%20class=%22bd-box%22%3E%3Ch-char%20class=%22bd%20bd-beg%22%3E%3Ch-inner%3E%EF%BC%89%3C/h-inner%3E%3C/h-char%3E%3C/span%3E"><span class="toc-number">2.</span> <span class="toc-text">生成函数（$\underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{GF}$）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.</span> <span class="toc-text">定义及性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%93%8D%E4%BD%9C%E5%92%8C-$%5Ctext%7Bogf%7D$"><span class="toc-number">2.2.</span> <span class="toc-text">常用的形式操作和 $\text{OGF}$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">找零问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">卡特兰数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%9E%90%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">简析生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#$%5Ctext%7B-ogf%7D$"><span class="toc-number">2.4.1.</span> <span class="toc-text">$\text{ OGF}$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#$%5Ctext%7Begf%7D$"><span class="toc-number">2.4.2.</span> <span class="toc-text">$\text{EGF}$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#$%5Ctext%7Bdgf%7D$"><span class="toc-number">2.4.3.</span> <span class="toc-text">$\text{DGF}$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">二元生成函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E6%A0%87%E5%8F%B7%E4%BD%93%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text">无标号体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">记号与定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%97%A0%E6%A0%87%E5%8F%B7%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">基础无标号类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">3.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E6%97%A0%E6%A0%87%E5%8F%B7%E6%9E%84%E9%80%A0"><span class="toc-number">4.</span> <span class="toc-text">经典的无标号构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84-$%5Ctext%7Bsequence%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">4.1.</span> <span class="toc-text">集合的 $\text{Sequence}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84-$%5Ctext%7Bmultiset%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">4.2.</span> <span class="toc-text">集合的 $\text{Multiset}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84-$%5Ctext%7Bpowerset%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">4.3.</span> <span class="toc-text">集合的 $\text{Powerset}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84-$%5Ctext%7Bamplification%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">4.4.</span> <span class="toc-text">集合的 $\text{Amplification}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84-$%5Ctext%7Bcycle%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">4.5.</span> <span class="toc-text">集合的 $\text{Cycle}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">4.6.</span> <span class="toc-text">有限制的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-number">4.7.</span> <span class="toc-text">隐式构造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7%E4%BD%93%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text">有标号体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7%E4%B8%8E%E5%AE%9A%E4%B9%89-1"><span class="toc-number">5.2.</span> <span class="toc-text">记号与定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9C%89%E6%A0%87%E5%8F%B7%E7%B1%BB%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">基础有标号类与操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E6%9C%89%E6%A0%87%E5%8F%B7%E6%9E%84%E9%80%A0"><span class="toc-number">6.</span> <span class="toc-text">经典的有标号构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7-$%5Ctext%7Bsequence%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">6.1.</span> <span class="toc-text">有标号 $\text{Sequence}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7-$%5Ctext%7Bset%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">6.2.</span> <span class="toc-text">有标号 $\text{Set}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7-$%5Ctext%7Bcycle%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">6.3.</span> <span class="toc-text">有标号 $\text{Cycle}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7-$%5Ctext%7Bpointing%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">6.4.</span> <span class="toc-text">有标号 $\text{Pointing}$ 构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%A0%87%E5%8F%B7-$%5Ctext%7Bsubstitution%7D$%20%E6%9E%84%E9%80%A0"><span class="toc-number">6.5.</span> <span class="toc-text">有标号 $\text{Substitution}$ 构造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#d-finite-%E4%B8%8E%20ode%20%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">d-finite 与 ODE 自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%5B%E5%AE%9A%E4%B9%89%5D(https://wwwmath.ucla.edu/~pak/papers/garrabrant-thesis.pdf)"><span class="toc-number">7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">7.2.</span> <span class="toc-text">基础函数的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%3Cspan-class=%22bd-box%22%3E%3Ch-char%20class=%22bd%20bd-beg%22%3E%3Ch-inner%3E%EF%BC%9F%3C/h-inner%3E%3C/h-char%3E%3C/span%3E"><span class="toc-number">7.3.</span> <span class="toc-text">如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#$f(x)-+%20g(x)$"><span class="toc-number">7.3.1.</span> <span class="toc-text">$f(x) + g(x)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#$f(x)g(x)$"><span class="toc-number">7.3.2.</span> <span class="toc-text">$f(x)g(x)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#$f-%5Ccirc%20g$"><span class="toc-number">7.3.3.</span> <span class="toc-text">$f \circ g$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">8.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%BE%AE%E7%A7%AF%E5%88%86"><span class="toc-number">8.1.</span> <span class="toc-text">经典微积分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%BE%AE%E7%A7%AF%E5%88%86"><span class="toc-number">8.2.</span> <span class="toc-text">离散微积分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E7%BA%A7%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">一些具体的级数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E7%BA%A7%E6%95%B0"><span class="toc-number">8.3.1.</span> <span class="toc-text">广义二项级数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E6%8C%87%E6%95%B0%E7%BA%A7%E6%95%B0"><span class="toc-number">8.3.2.</span> <span class="toc-text">广义指数级数</span></a></li></ol></li></ol></li></ol>
</div>

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="多项式与幂级数">多项式与幂级数</h1>
<h2 id="基础定义">基础定义</h2>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.1.1 } \text{(多项式) }$</span></p>
<p>一个多项式 <span class="markdown-them-math-inline">$f$</span> 形如</p>
<p><div class="markdown-them-math-block">$$f(x) = \sum_{i=0}^n a_i x^i,\quad a_n\neq 0$$</div></p>
</blockquote>
<p>其中 <span class="markdown-them-math-inline">$a_i$</span> 被称为多项式 <span class="markdown-them-math-inline">$f$</span> 的第 <span class="markdown-them-math-inline">$i$</span> 项系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span> 被称为多项式 <span class="markdown-them-math-inline">$f$</span> 的度数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>次数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$\deg f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>度数有时可以取 <span class="markdown-them-math-inline">$\infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时这个多项式也可以被称为幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一般地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$f(x)$</span> 的第 <span class="markdown-them-math-inline">$i$</span> 项系数为 <span class="markdown-them-math-inline">$[x^i]f(x)$</span> 或 <span class="markdown-them-math-inline">$f[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为简便<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在上下文信息足够时可以将形如 <span class="markdown-them-math-inline">$f(x)$</span> 的多项式记作 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
由一些基础数学知识可以知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个 <span class="markdown-them-math-inline">$n$</span> 次多项式的系数和 <span class="markdown-them-math-inline">$n + 1$</span> 个点值是可以互相唯一地得到的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由系数得到点值的操作被称为多点求值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由点值得到系数的操作被称为插值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在接下来的内容中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们一般不关心当 <span class="markdown-them-math-inline">$x$</span> 为某个特定的值时 <span class="markdown-them-math-inline">$f(x)$</span> 的取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而会将它作为一个操作系数的工具使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般称之为操作对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们认为 <span class="markdown-them-math-inline">$x$</span> 只是一个占位符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>起到对系数某一信息的标识作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种情况下将幂级数称作形式幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>很多时候我们无力操作度数过于大的多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就需要一个度数的界 <span class="markdown-them-math-inline">$\pmod {x^n}$</span> 来限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果度数均是非负整数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且运算均由卷积定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在操作中我们可以只保留界以内的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x) \bmod x^n$</span> 被称作 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$n$</span> 次项内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的一个截取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于一般的环 <span class="markdown-them-math-inline">$R$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义系数 <span class="markdown-them-math-inline">$\in R$</span> 的所有多项式 <span class="markdown-them-math-inline">$f(x)$</span> 组成一个多项式环 <span class="markdown-them-math-inline">$R[x]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意 <span class="markdown-them-math-inline">$f\in R[x]$</span> 都可以表示为系数列 <span class="markdown-them-math-inline">$\langle f_n\rangle$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考察度取到 <span class="markdown-them-math-inline">$+\infty$</span> 的 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称 <span class="markdown-them-math-inline">$f$</span> 的全体组成一个形式幂级数环 <span class="markdown-them-math-inline">$R[[x]]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的任意元素 <span class="markdown-them-math-inline">$f$</span> 都被称作一个形式幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在不引起歧义的情况下可以简称幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
在 OI 应用中/下文中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$R$</span> 一般定义在模 <span class="markdown-them-math-inline">$p$</span> 整数集 <span class="markdown-them-math-inline">$\mathbb F_p = GF(p)$</span> 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>更特殊地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p$</span> 常可以被表示为 <span class="markdown-them-math-inline">$a\times 2^k + 1$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$k$</span> 应当较大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下文中更常见的是对无穷序列的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只是在某个特殊位置截断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时更应当称其为幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然而<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多项式和幂级数都只是用于指代我们所操作对象的名称<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体含义应视上下文而定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>定义对一个常数项为 <span class="markdown-them-math-inline">$0$</span> 的幂级数 <span class="markdown-them-math-inline">$f(x)$</span> 进行左移得到 <span class="markdown-them-math-inline">$\dfrac{f(x)}{x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>定义对一个幂级数 <span class="markdown-them-math-inline">$f(x)$</span> 进行右移得到 <span class="markdown-them-math-inline">$xf(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>操作多项式的核心是两个多项式的乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个操作又称卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.1.2 } \text{(卷积/乘法) }$</span></p>
<p>给定两个多项式 <span class="markdown-them-math-inline">$f, g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>度数分别为 <span class="markdown-them-math-inline">$n, m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>二者的卷积/乘法 <span class="markdown-them-math-inline">$f\times g$</span> 定义如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$f\times g = \sum_{i=0}^n \sum_{j=0}^m f[i]g[j] x^{i + j}$$</div></p>
</blockquote>
<p>可以发现卷积得到的多项式的度数是给定多项式的度数相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从系数的角度去观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>推得</p>
<p><div class="markdown-them-math-block">$$[x^k](f\times g) = \sum_{i = 0}^k f[i]g[k - i]$$</div></p>
<p>承接上文对 <span class="markdown-them-math-inline">$p$</span> 的讨论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$R$</span> 上存在 <span class="markdown-them-math-inline">$2^k$</span> 次单位根时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>快速傅里叶变换允许我们在 <span class="markdown-them-math-inline">$O(k2^k)$</span> 的时间复杂度内计算两个多项式的乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这类整数集对应的模数 <span class="markdown-them-math-inline">$p$</span> 又被称作 NTT 模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常见的有 <span class="markdown-them-math-inline">$998244353,\ 1004535809,\ 167772161$</span> 等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后有了乘法就能自然定义除法和取模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先定义一个幂级数 <span class="markdown-them-math-inline">$f(x)$</span> 在 <span class="markdown-them-math-inline">$\text{mod } {x^n}$</span> 意义下的乘法逆 <span class="markdown-them-math-inline">$g(x)$</span> 满足 <span class="markdown-them-math-inline">$f(x)\times g(x) \equiv 1 \pmod{x^n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现 <span class="markdown-them-math-inline">$f(x)$</span> 有乘法逆当且仅当 <span class="markdown-them-math-inline">$f[0] \neq 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.1.3 } \text{(带余除法) }$</span></p>
<p>给定两个多项式 <span class="markdown-them-math-inline">$f, g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>度数分别为 <span class="markdown-them-math-inline">$n, m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>存在唯一的 <span class="markdown-them-math-inline">$Q, R$</span> 满足</p>
<p><div class="markdown-them-math-block">$$f(x) = Q(x) g(x) + R(x) \quad \deg R &lt; \deg g$$</div></p>
<p>当 <span class="markdown-them-math-inline">$\deg f \ge \deg g$</span> 时 <span class="markdown-them-math-inline">$\deg Q = \deg f - \deg g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>反之 <span class="markdown-them-math-inline">$=0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们称 <span class="markdown-them-math-inline">$Q$</span> 为 <span class="markdown-them-math-inline">$f$</span> 除 <span class="markdown-them-math-inline">$g$</span> 的商<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$R$</span> 为 <span class="markdown-them-math-inline">$f$</span> 除 <span class="markdown-them-math-inline">$g$</span> 的余数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>幂级数乃至有理函数的复合是下文中很重要的一类操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>尤其在应用拉格朗日反演时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此这里首先介绍复合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.1.4 } \text{(复合) }$</span></p>
<p>给定两个多项式 <span class="markdown-them-math-inline">$f, g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>度数分别为 <span class="markdown-them-math-inline">$n, m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>二者的复合 <span class="markdown-them-math-inline">$f\circ g$</span> 定义如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$f\circ g = \sum_{i=0}^n f[i] g(x)^i$$</div></p>
<p><span class="markdown-them-math-inline">$(f\circ g)(x)$</span> 又常记作 <span class="markdown-them-math-inline">$f(g(x))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.1.5 } \text{(复合逆) }$</span></p>
<p>给定一个多项式 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的复合逆 <span class="markdown-them-math-inline">$f^{\langle -1 \rangle}$</span> 是满足 <span class="markdown-them-math-inline">$f\circ f^{\langle -1 \rangle} = x$</span> 的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>对于 DFT 相关的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以查阅<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/paperessay221127.html">本博客</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="多项式牛顿迭代">多项式牛顿迭代</h2>
<p>在第二节的描述中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们常常使用递归构造的幂级数作为操作对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这常常是由于幂级数的系数由给定的递推式获得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个幂级数 <span class="markdown-them-math-inline">$F(x)$</span> 是递归构造的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即说明 <span class="markdown-them-math-inline">$F(x)$</span> 可以由形如 <span class="markdown-them-math-inline">$F(x) = G(F(x))$</span> 的式子得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们现在需要做的就是先获得求解递归构造的幂级数的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们首先引出泰勒展开的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.2.1 } \text{(泰勒展开) }$</span></p>
<p>对于一个多项式 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以从 <span class="markdown-them-math-inline">$a$</span> 点处采用高阶导数用无穷级数展开它<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即</p>
<p><div class="markdown-them-math-block">$$F(x) = \sum_{i=0}^{\infty}\frac{F^{(i)}(a)}{i!}(x - a)^i$$</div></p>
</blockquote>
<p>在数学分析上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更实用的是 <span class="markdown-them-math-inline">$a = 0$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时得到的无穷级数被称作麦克劳林级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.2.2 } \text{(麦克劳林级数) }$</span></p>
<p>如上地写出形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$F(x) = \sum_{i=0}^{\infty}\frac{F^{(i)}(0)}{i!}x^i$$</div></p>
</blockquote>
<p>可以发现这是一个幂级数的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以通过麦克劳林级数导出一些简单的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并通过卷积来定义一些东西<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>经典例子是 <span class="markdown-them-math-inline">$e^x = \sum_{i=0}^{\infty}x^i / i!$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们常通过多项式牛顿迭代来获得 <span class="markdown-them-math-inline">$F(x)$</span> 的一个截取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在牛顿迭代的过程中度数是倍增的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此牛顿迭代本身一般不会带来复杂度的增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面给出多项式牛顿迭代的一般形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{引理 1.2.1 } \text{(牛顿迭代) }$</span></p>
<p>给定多项式 <span class="markdown-them-math-inline">$G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要求得多项式 <span class="markdown-them-math-inline">$F$</span> 满足 <span class="markdown-them-math-inline">$G(F(x)) \equiv 0 \pmod{x^{2n}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若已知 <span class="markdown-them-math-inline">$F_0(x)\equiv F(x) \pmod{x^n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$F$</span> 由下式给出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$F(x) = F_0(x) - \frac{G(F_0(x))}{G'(F_0(x))}$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>由于 <span class="markdown-them-math-inline">$F_0(x)$</span> 也满足 <span class="markdown-them-math-inline">$G(F_0(x)) \equiv 0 \pmod{x^{n}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$F(x) - F_0(x) \equiv 0 \pmod{x^n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$F(x) - F_0(x)$</span> 的最低次项次数 <span class="markdown-them-math-inline">$\ge n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们将 <span class="markdown-them-math-inline">$G(F(x))$</span> 在 <span class="markdown-them-math-inline">$F_0(x)$</span> 处展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$G(F(x)) = \sum_{i=0}^{\infty} G^{(i)}(F_0(x)) \frac{(F(x) - F_0(x))^i}{i!}$$</div></p>
<p>由于 <span class="markdown-them-math-inline">$i &gt; 1$</span> 时 <span class="markdown-them-math-inline">$(F(x) - F_0(x))^i$</span> 最低次项次数 <span class="markdown-them-math-inline">$\ge 2n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此在 <span class="markdown-them-math-inline">$x^{2n}$</span> 处截断后 <span class="markdown-them-math-inline">$i &gt; 1$</span> 的项都是不必要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此得到</p>
<p><div class="markdown-them-math-block">$$G(F(x)) = G(F_0(x)) + G'(F_0(x)) (F(x) - F_0(x))$$</div></p>
<p>整理即可得到牛顿迭代的表达形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>关于优化该做法常数的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以查阅<a target="_blank" rel="noopener" href="https://negiizhao.blog.uoj.ac/blog/4671">关于优化形式幂级数计算的 Newton 法的常数, negiizhao</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><s>然而需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>费脑子卡你板子的常还不如先打一个半在线卷积</s></p>
<h2 id="形式-$\text{laurent}$ 级数">形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数</h2>
<p>我们可以构造一类非正式的幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足其最低次项为 <span class="markdown-them-math-inline">$n_0 \in \mathbb Z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种级数被称作形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数可以看作是普通幂级数的一种延拓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先给出定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.3.1 }\text{(形式 Laurent 级数)}$</span></p>
<p>一个最低次项为 <span class="markdown-them-math-inline">$n_0$</span> 次的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$A(x)$</span> 被定义为<br>
<div class="markdown-them-math-block">$$A(x) = \sum_{i=n_0}^{\infty} a_i x^i$$</div></p>
</blockquote>
<p>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于不同的两个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>二者的 <span class="markdown-them-math-inline">$n_0$</span> 可能不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以看到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$n_0 \ge 0$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数就是普通的幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数的形式运算和正常幂级数类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面只对除法进行展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于两个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数的除法运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要先对其作转化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们将 <span class="markdown-them-math-inline">$A(x)$</span> 改写成如下形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$x^{n_0} \sum_{i \ge 0} a_{i + n_0} x^i$$</div></p>
<p>即 <span class="markdown-them-math-inline">$x^{n_0}$</span> 乘上一个幂级数的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于 <span class="markdown-them-math-inline">$n_0$</span> 分别为 <span class="markdown-them-math-inline">$n_a, n_b$</span> 的两个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$A, B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义 <span class="markdown-them-math-inline">$A / B$</span> 的结果是一个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足</p>
<p><div class="markdown-them-math-block">$$C(x) = x^{n_a - n_b} \frac{\sum_{i\ge 0} a_{i + n_a} x^i}{\sum_{i \ge 0} b_{i + n_b} x^i}$$</div></p>
<p>因此 <span class="markdown-them-math-inline">$C$</span> 是一个 <span class="markdown-them-math-inline">$n_0 = n_a - n_b$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数可以通过系数的位移采用经典幂级数表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但我们为何要定义如此的一个函数呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>答案将随着接下来对形式留数的探讨揭晓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 1.3.2 }\text{(形式留数)}$</span></p>
<p>一个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数的形式留数为 <span class="markdown-them-math-inline">$x^{-1}$</span> 次项前的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>自然地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以得出以下引理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{引理 1.3.1 }$</span></p>
<p>一个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数求导后形式留数为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>注意到 <span class="markdown-them-math-inline">$x^0$</span> 在求导后系数不会传递给 <span class="markdown-them-math-inline">$x^{-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$x^{-1}$</span> 在求导后系数会传递给 <span class="markdown-them-math-inline">$x^{-2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{引理 1.3.2 }$</span></p>
<p>对于 <span class="markdown-them-math-inline">$n_0 = 1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$A(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$A'(x)A^k (x)$</span> 的形式留数为 <span class="markdown-them-math-inline">$[k = -1]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>当 <span class="markdown-them-math-inline">$k \neq -1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$A'(x)A^k(x) = \left(A^{k + 1}(x) / (k + 1)\right)'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由引理 <span class="markdown-them-math-inline">$1.3.1$</span> 得到其为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><br>
当 <span class="markdown-them-math-inline">$k = -1$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\frac{A'(x)}{A(x)} = x^{-1} \frac{1 + \frac{2a_2}{a_1}x + \frac{3a_3}{a_1}x^3 + \cdots}{1 + \frac{a_2}{a_1}x + \frac{a_3}{a_1}x^3 + \cdots}$$</div></p>
<p>后面的分式是一个 <span class="markdown-them-math-inline">$n_0 = 0$</span> 且常数项为 <span class="markdown-them-math-inline">$1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>到了这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以用形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数来做一些事情了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将证明一系列拉格朗日反演公式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="拉格朗日反演">拉格朗日反演</h2>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.4.1 }\text{(拉格朗日反演)}$</span></p>
<p>给定一个 <span class="markdown-them-math-inline">$n_0 = 1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$Q(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于任意整数 <span class="markdown-them-math-inline">$n, k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<br>
<div class="markdown-them-math-block">$$n[x^n]Q^k(x) = k[x^{-k}]\left(Q^{\langle -1\rangle}(x)\right)^{-n}$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>我们将复合逆的定义两边求 <span class="markdown-them-math-inline">$k$</span> 次方得到<br>
<div class="markdown-them-math-block">$$Q^k (Q^{\langle -1\rangle}(x)) = x^k$$</div></p>
<p>两边求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里强调 <span class="markdown-them-math-inline">$f'(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$(f)'(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\left(Q^{\langle -1\rangle}(x)\right)' \left(Q^k\right)'\left(Q^{\langle -1\rangle}(x)\right) = k x^{k-1} $$</div></p>
<p>两边乘 <span class="markdown-them-math-inline">$\left(Q^{\langle -1\rangle}(x)\right)^{-n}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时将函数 <span class="markdown-them-math-inline">$(Q^k)'$</span> 展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$\left(Q^{\langle -1\rangle}(x)\right)' \left(\sum_{i} i [z^i]Q^k(z) \times \left(Q^{\langle -1\rangle}(x)\right) ^{i - 1 - n} \right) = k x^{k-1}\left(Q^{\langle -1\rangle}(x)\right)^{-n} $$</div></p>
<p>我们把最前面的 <span class="markdown-them-math-inline">$\left(Q^{\langle -1\rangle}(x)\right)'$</span> 和 <span class="markdown-them-math-inline">$\left(\left(Q^{\langle -1\rangle}(x)\right) ^{i - 1 - n} \right)$</span> 乘起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到引理 <span class="markdown-them-math-inline">$1.3.2$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并取左右两边的形式留数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$\sum_{i} i [z^i]Q^k(z) \times [x^{-1}] \left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right) ^{i - 1 - n} = [x^{-1}]k x^{k-1}\left(Q^{\langle -1\rangle}(x)\right)^{-n} $$</div></p>
<p>由引理 <span class="markdown-them-math-inline">$1.3.2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只有 <span class="markdown-them-math-inline">$n = i$</span> 时才有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就得到了</p>
<p><div class="markdown-them-math-block">$$n [z^n]Q^k(z) = k [x^{-k}]\left(Q^{\langle -1\rangle}(x)\right)^{-n} $$</div></p>
<p>得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>EI 的十行证明是怎么来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></summary>
<p>其实就是把上面的东西压缩了一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$P(Q(x)) = x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要证的就是 <span class="markdown-them-math-inline">$n[x^n]P^k(x) = k[x^{-k}]Q^{-n}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
P^k(Q) &amp;= x^k \\
Q'\left(P^k\right)'(Q) &amp;= kx^{k-1} \\
Q'\sum_{i\ge n_0} i \left([x^i] P^k(x) \right) Q^{i - 1}(x)&amp;= kx^{k-1} \\
Q'\sum_{i\ge n_0} i \left([x^i] P^k(x) \right) Q^{i - 1 - n}(x) &amp;= kx^{k - 1} Q^{-n}(x)  \\
[x^{-1}] \sum_{i\ge n_0} i \left([x^i] P^k(x) \right) Q^{i - 1 - n}(x)  Q' &amp;= [x^{-1}] kx^{k - 1} Q^{-n}(x) \\
\sum_{i\ge n_0} i \left([x^i] P^k(x) \right) \left([x^{-1}] Q^{i - 1 - n}(x)  Q'\right) &amp;= k[x^{-k}] Q^{-n}(x) \\
n [x^n] P^k(x) &amp;= k[x^{-k}] Q^{-n}(x) \\
\end{aligned}$$</div></p>
<p>最后一步使用了引理 <span class="markdown-them-math-inline">$\text{1.3.2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要 <span class="markdown-them-math-inline">$i - 1 - n = -1$</span> 的 <span class="markdown-them-math-inline">$i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$i = n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</details>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.4.2 }\text{(拓展拉格朗日反演)}$</span></p>
<p>给定一个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$P(x)$</span> 和一个 <span class="markdown-them-math-inline">$n_0 = 1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$Q(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于非零整数 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<br>
<div class="markdown-them-math-block">$$[x^n] P(Q(x)) = \frac{1}{n} [x^{n-1}]P'(x) \left(\frac{x}{Q^{\langle -1 \rangle}(x)}\right)^n$$</div></p>
</blockquote>
<p>我们只需要针对 <span class="markdown-them-math-inline">$P(x) = px^k$</span> 的形式验证即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于 <span class="markdown-them-math-inline">$P$</span> 由多项组成的情况可以求和解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>两边变成<br>
<div class="markdown-them-math-block">$$p[x^n] Q^k(x) = \frac{p}{n} [x^{-1}] k x^{k-1} \left(Q^{\langle -1 \rangle}(x)\right)^{-n}$$</div></p>
<p>这其实就是定理 <span class="markdown-them-math-inline">$1.4.1$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>拓展拉格朗日反演的形式往往更适合 OI 中的计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是由于 <span class="markdown-them-math-inline">$Q^{\langle -1 \rangle}$</span> 是一个幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而当 <span class="markdown-them-math-inline">$P$</span> 也是幂级数时整个的形式就很友好了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只要我们能计算复合逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就能直接转成幂级数的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>复合逆的计算一般采用迭代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当然这两个公式在一些情况下的应用不是很顺畅<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此 EI 提出了另类拉格朗日反演<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形式如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.4.3 }\text{(另类拉格朗日反演)}$</span></p>
<p>给定一个 <span class="markdown-them-math-inline">$n_0 = 1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$Q(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于任意整数 <span class="markdown-them-math-inline">$n, k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有</p>
<p><div class="markdown-them-math-block">$$[x^n] Q^k(x) = [x^{-k-1}] \left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{-n-1}$$</div></p>
</blockquote>
<p>仍然考虑从复合逆的定义两边 <span class="markdown-them-math-inline">$k$</span> 次方入手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$Q^k (Q^{\langle -1\rangle}(x)) = x^k$$</div></p>
<p>不需要求导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接将左边展开并乘入右边缺的 <span class="markdown-them-math-inline">$\left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{-n-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\sum_{i} [z^i] Q^k(z) \left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{i-n-1}= x^k\left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{-n-1}$$</div></p>
<p>两边取形式留数得到</p>
<p><div class="markdown-them-math-block">$$\sum_{i} [z^i] Q^k(z) [x^{-1}] \left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{i-n-1}= [x^{-k-1}]\left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{-n-1}$$</div></p>
<p>同样考虑只有 <span class="markdown-them-math-inline">$n = i$</span> 时有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$[z^n] Q^k(z) = [x^{-k-1}]\left(Q^{\langle -1\rangle}(x)\right)'\left(Q^{\langle -1\rangle}(x)\right)^{-n-1}$$</div></p>
<p>得证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>同样的手法可以用于求得更实用的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>该叫拓展另类拉格朗日反演<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.4.4 }\text{(另类拉格朗日反演)}$</span></p>
<p>给定一个形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$P(x)$</span> 和一个 <span class="markdown-them-math-inline">$n_0 = 1$</span> 的形式 <span class="markdown-them-math-inline">$\text{Laurent}$</span> 级数 <span class="markdown-them-math-inline">$Q(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于整数 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<br>
<div class="markdown-them-math-block">$$[x^n] P(Q(x)) = [x^{n}]P(x) \left(Q^{\langle -1\rangle}(x)\right)' \left(\frac{x}{Q^{\langle -1 \rangle}(x)}\right)^{n + 1}$$</div></p>
</blockquote>
<p>我们只需要针对 <span class="markdown-them-math-inline">$P(x) = px^k$</span> 的形式验证即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于 <span class="markdown-them-math-inline">$P$</span> 由多项组成的情况可以求和解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>两边变成<br>
<div class="markdown-them-math-block">$$p[x^n] Q^k(x) = p [x^{n - k - n - 1}] \left(Q^{\langle -1\rangle}(x)\right)' \left(Q^{\langle -1 \rangle}(x)\right)^{- n - 1}$$</div></p>
<p>这其实就是定理 <span class="markdown-them-math-inline">$1.4.3$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>重新写出常用的两个拉格朗日反演形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$[x^n] P(Q(x)) = \frac{1}{n} [x^{n-1}]P'(x) \left(\frac{x}{Q^{\langle -1 \rangle}(x)}\right)^n$$</div><br>
<div class="markdown-them-math-block">$$[x^n] P(Q(x)) = [x^{n}]P(x) \left(Q^{\langle -1\rangle}(x)\right)' \left(\frac{x}{Q^{\langle -1 \rangle}(x)}\right)^{n + 1}$$</div></p>
<p>然后我们就能用他们去推导一系列问题了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>应用牛顿迭代和拉格朗日反演的例题<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/editorchat221215.html#%E4%B8%A4%E9%81%93%E8%AE%A1%E6%95%B0%E9%A2%98">见此</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>附 <span class="markdown-them-math-inline">$3$</span> 也是应用拉格朗日反演证明的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/-/chitchat240623">多元拉格朗日反演</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="分式分解">分式分解</h2>
<p>在正式阐述分式分解的形式前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要先引入一个有着良好性质的分式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\frac{a}{(1 - \rho z)^{m + 1}}= \sum_{n \ge 0} \binom{m + n}{m} a\rho^n z^n$$</div></p>
<p>可以采用归纳法证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不再赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一个有限个级数的和函数 <span class="markdown-them-math-inline">$S(z)$</span> 也具有良好的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其形式为</p>
<p><div class="markdown-them-math-block">$$S(z) = \frac{a_1}{(1 - \rho_1 z)^{m_1 + 1}} + \frac{a_2}{(1 - \rho_2 z)^{m_2 + 1}} + \cdots + \frac{a_l}{(1 - \rho_l z)^{m_l + 1}}$$</div></p>
<p>这是由于我们可以轻易地提取系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$[z^n]S(z) = a_1\binom{m_1 + n}{m_1} \rho_1^n + a_2\binom{m_2 + n}{m_2} \rho_2^n + \cdots + a_l\binom{m_l + n}{m_l} \rho_l^n$$</div></p>
<p>可以证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意 <span class="markdown-them-math-inline">$R(0) \neq \infty$</span> 的有理函数</p>
<p><div class="markdown-them-math-block">$$R(z) = \frac{P(z)}{Q(z)}$$</div></p>
<p>都可以被写成形如 <span class="markdown-them-math-inline">$S(z) + T(z)$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$S(z)$</span> 如上定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$T(z)$</span> 是一个多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此对于 <span class="markdown-them-math-inline">$R(z)$</span> 的系数总有一个封闭形式来表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求得 <span class="markdown-them-math-inline">$S(z)$</span> 与 <span class="markdown-them-math-inline">$T(z)$</span> 等价于找到 <span class="markdown-them-math-inline">$R(z)$</span> 的<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/partial-fraction-expansion/"><span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>部分分式展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span></a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>注意到 <span class="markdown-them-math-inline">$T(z)$</span> 在 <span class="markdown-them-math-inline">$z \neq \infty$</span> 时定不为 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$R(z) = \infty$</span> 的情况只能说明 <span class="markdown-them-math-inline">$S(z) = \infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$z \in\{1/\rho_1 , 1/\rho_2 ,\dots, 1/\rho_l\}$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此如果我们想顺利地将 <span class="markdown-them-math-inline">$R(z)$</span> 表为 <span class="markdown-them-math-inline">$S(z) + T(z)$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所需的每个 <span class="markdown-them-math-inline">$\rho_i$</span> 就应当分别是 <span class="markdown-them-math-inline">$Q(\alpha)$</span> 的零点 <span class="markdown-them-math-inline">$\alpha_i$</span> 的倒数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们假设 <span class="markdown-them-math-inline">$Q(z)$</span> 形如</p>
<p><div class="markdown-them-math-block">$$Q(z) = q_0 + q_1z + \cdots + q_mz^m $$</div></p>
<p>需要满足 <span class="markdown-them-math-inline">$q_0, q_m \neq 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义 <span class="markdown-them-math-inline">$Q(z)$</span> 的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>翻转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> <span class="markdown-them-math-inline">$Q^{R}(z)$</span> 形如</p>
<p><div class="markdown-them-math-block">$$Q^{R}(z) = q_0 z^m + q_1z^{m-1} + \cdots + q_m$$</div></p>
<p>我们可以发现 <span class="markdown-them-math-inline">$Q(z)$</span> 和它的翻转具有以下的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>$<span class="markdown-them-math-inline">$\begin{aligned}
Q^R(z) &amp; = q_0 (z - \rho_1) (z - \rho_2) \cdots (z - \rho_m) \\
Q(z) &amp; = q_0 (1 - \rho_1z) (1 - \rho_2z) \cdots (1 - \rho_mz) \\
\end{aligned}$</span></p>
<p>这表明一个多项式 <span class="markdown-them-math-inline">$Q(z)$</span> 的零点是它翻转的对应零点的倒数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们若想找到 <span class="markdown-them-math-inline">$\rho_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就可以将 <span class="markdown-them-math-inline">$Q^R(z)$</span> 进行分式分解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体的应用将会在下方给出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在首先介绍两条定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.5.1 }\text{(不同根的有理展开定理)}$</span></p>
<p>设 <span class="markdown-them-math-inline">$R(z) = P(z) / Q(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$Q(z) = q_0(1 - \rho_1z) (1 - \rho_2z) \cdots (1 - \rho_lz)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\rho_1, \rho_2, \dots, \rho_l$</span> 彼此不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$P(z)$</span> 是一个度数小于 <span class="markdown-them-math-inline">$l$</span> 的多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们有</p>
<p><div class="markdown-them-math-block">$$[z^n]R(z) = a_1 \rho_1^n + \cdots + a_l \rho_l^n, \qquad a_k = \frac{-\rho_k P(1 / \rho_k)}{Q'(1 / \rho_k)}$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$a_i$</span> 如上地定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果定理成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$R(z) = P(z)/Q(z)$</span> 应当等于<br>
<div class="markdown-them-math-block">$$S(z) = \frac{a_1}{1 - \rho_1z} + \frac{a_2}{1 - \rho_2z} + \cdots + \frac{a_l}{1 - \rho_lz}$$</div></p>
<p>为证明这一点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要证明 <span class="markdown-them-math-inline">$T(z) = R(z) - S(z)$</span> 在 <span class="markdown-them-math-inline">$z \to 1 / \rho_i$</span> 时不会趋向正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这将表明一个分式永远不可能取得正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是这个分式退化为了一个多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们同样可以证明当 <span class="markdown-them-math-inline">$z \to \infty$</span> 时 <span class="markdown-them-math-inline">$T(z)\to 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这表明 <span class="markdown-them-math-inline">$T(z) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$\alpha_i = 1 / \rho_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>为证明 <span class="markdown-them-math-inline">$\lim_{z\to \alpha_i} T(z) \neq \infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需证明 <span class="markdown-them-math-inline">$\lim_{z\to \alpha_i} (z - \alpha_i)T(z) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是由于 <span class="markdown-them-math-inline">$T(z)$</span> 是一个有理函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们想证明的即为</p>
<p><div class="markdown-them-math-block">$$\lim_{z\to \alpha_i} (z - \alpha_i) R(z) = \lim_{z\to \alpha_i}(z - \alpha_i) S(z)$$</div></p>
<p>等号右侧的处理是简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对任意 <span class="markdown-them-math-inline">$j \neq i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有<br>
<div class="markdown-them-math-block">$$\lim_{z\to \alpha_i} \frac{a_j (z - \alpha_i)}{1 - \rho_jz} = 0$$</div></p>
<p>因此等号右侧只剩第 <span class="markdown-them-math-inline">$i$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>消同类项得到右侧即为 <span class="markdown-them-math-inline">$\dfrac{-a_i}{\rho_i} = \dfrac{P(\alpha_i)}{Q'(\alpha_i)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>左侧的极限可以通过洛必达法则<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>定理 附 <span class="markdown-them-math-inline">$1.1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>求得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\lim_{z \to \alpha_i} (z - \alpha_i)\frac{P(z)}{Q(z)} = P(\alpha_i)\lim_{z \to \alpha_i} \frac{z - \alpha_i}{Q(z)} = \frac{P(\alpha_i)}{Q'(\alpha_i)} $$</div></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就解决了 <span class="markdown-them-math-inline">$Q(z)$</span> 无重根的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$Q(z)$</span> 存在重根时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算就会变得复杂起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是我们仍然可以加强我们得到的结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到以下的一般结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 1.5.2 }\text{(有理生成函数的一般展开定理)}$</span></p>
<p>设 <span class="markdown-them-math-inline">$R(z) = P(z) / Q(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$Q(z) = q_0(1 - \rho_1z)^{d_1} (1 - \rho_2z)^{d_2} \cdots (1 - \rho_lz)^{d_l}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$\rho_1, \rho_2, \dots, \rho_l$</span> 彼此不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$P(z)$</span> 是一个度数小于 <span class="markdown-them-math-inline">$l$</span> 的多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们有</p>
<p><div class="markdown-them-math-block">$$[z^n]R(z) = f_1(n) \rho_1^n + \cdots + f_l(n) \rho_l^n$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$f_k(n)$</span> 是一个 <span class="markdown-them-math-inline">$d_k - 1$</span> 度的多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其首项系数为</p>
<p><div class="markdown-them-math-block">$$a_k = \frac{-\rho_k^{d_k} P(1/\rho_k)d_k}{Q^{(d_k)}(1 / \rho_k)} = \frac{P(1 / \rho_k)}{(d_k - 1)! q_0 \prod_{j\neq k} (1 - p_j / p_k)^{d_j}}$$</div></p>
</blockquote>
<p>此定理可以通过在 <span class="markdown-them-math-inline">$\max \{d_i\}$</span> 上做归纳得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要用到</p>
<p><div class="markdown-them-math-block">$$R(z) - \frac{a_1(d_1 - 1)!}{(1 - \rho_1z)^{d_1}} - \frac{a_2(d_2 - 1)!}{(1 - \rho_2z)^{d_2}} - \cdots - \frac{a_l(d_l - 1)!}{(1 - \rho_lz)^{d_l}}$$</div></p>
<p>是一个分母多项式无法被任意 <span class="markdown-them-math-inline">$(1 - \rho_k z)^{d_k}$</span> 整除的有理函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该定理本身无法确定任意 <span class="markdown-them-math-inline">$f_i$</span> 的表示形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要使用待定系数法求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在实际应用中不好使用如上的两种做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里也提供一些做法以供代替使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面仍然定义 <span class="markdown-them-math-inline">$R(z) = P(z) / Q(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>第一种方法是找到一个 <span class="markdown-them-math-inline">$(1 - z^k)^t$</span> 满足 <span class="markdown-them-math-inline">$Q(z) \mid (1 - z^k)^t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时我们可以将一个简单的形式放在分子上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们记 <span class="markdown-them-math-inline">$A(z) = \dfrac{(1 - z^k)^t}{Q(z)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$R(z) = \dfrac{A(z)P(z)}{(1 - z^k)^t}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们应当构造尽量简单的封闭形式来表出 <span class="markdown-them-math-inline">$R(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>第二种方法是待定系数法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是常见的做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体内容在<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/partial-fraction-expansion/">上面的链接</a>中有讲述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>到这里幂级数相关的知识就大致介绍完了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面我们将介绍——</p>
<h1 id="生成函数&lt;span-class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-end&quot;&gt;&lt;h-inner&gt;（&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;$\underline{\textbf{g}}\text{enerating} \ \underline{\textbf{f}}\text{unction}, \ \text{gf}$&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;）&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;">生成函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{GF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></h1>
<blockquote>
<p>生成函数是一种工具<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就像是一个袋子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们并不去独立地考察那些个体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那是很愚蠢的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>相反<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将它们全部放进一个袋子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们所需要考察的对象就只有一个了——那袋子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div align="right">—— $\text{George Polya}\qquad$</div>
</blockquote>
<h2 id="定义及性质">定义及性质</h2>
<p>一个无穷序列的生成函数是一个形式幂级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一项的系数可以提供关于这个序列每个元素的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>生成函数的构造应当是易于在具体情况下分析序列信息的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面具体定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{2.1.1 }\text{(生成函数)}$</span></p>
<p>对于一个无穷数列 <span class="markdown-them-math-inline">$\langle a_i \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义其关于占位元 <span class="markdown-them-math-inline">$k_i(x)$</span> 的生成函数 <span class="markdown-them-math-inline">$F(x)$</span> 如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$F(x) = \sum_{i = 0}^{\infty} a_i k_i(x)$$</div></p>
</blockquote>
<p>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>占位元的不同取法分别对应着不同的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常见的例子如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$k_i(x) = x^i$</span><br>
这对应着普通生成函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\underline{\textbf{O}}\text{rdinary} \ \underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{OGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其常用于组合问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$k_i(x) = \dfrac{x^i}{i!}$</span><br>
这对应着指数生成函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\underline{\textbf{E}}\text{xponential} \ \underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{EGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其常用于排列问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$k_i(x) = \dfrac{1}{i^x}$</span><br>
这对应着狄利克雷生成函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\underline{\textbf{D}}\text{irichlet} \ \underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{DGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其常用于元素按狄利克雷卷积贡献的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>我们在下面常用 <span class="markdown-them-math-inline">$\text{OGF}$</span> 作例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>给定一个数列 <span class="markdown-them-math-inline">$\langle 1, 1, 1, \dots \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以写出它的 <span class="markdown-them-math-inline">$\text{OGF } F(x)$</span> 如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$F(x) = \sum_{i=0}^{\infty} x^i = 1 + x^2 + x^3 + \cdots$$</div></p>
<p>这样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就将一个数列用一个函数表示出来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在需要第 <span class="markdown-them-math-inline">$i$</span> 项时只需要提取系数即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但我们时时都带着一个求和号运算是很不方便的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就启发我们去寻找一个更加简便的形式表示生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个形式常被称作封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个生成函数的封闭形式有时不唯一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>你可以把简明地表述这个数列的任意形式叫做封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>考虑生成函数的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>函数值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>是完全无意义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只关心生成函数每一项对应的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及数列在幂级数形式下表现的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>例如 <span class="markdown-them-math-inline">$F(x) = 1 + x^2 + x^3 + \cdots$</span> 满足 <span class="markdown-them-math-inline">$F(x) = xF(x) + 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$F(x)$</span> 的封闭形式为 <span class="markdown-them-math-inline">$\dfrac{1}{1 - x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>数列 <span class="markdown-them-math-inline">$1, p, p^2, \dots$</span> 的 <span class="markdown-them-math-inline">$\text{OGF}$</span> <span class="markdown-them-math-inline">$F(x) = \sum_{i=0}^{\infty} (px)^i$</span> 的封闭形式也可以类似地导出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是 <span class="markdown-them-math-inline">$\dfrac {1}{1 - px}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="常用的形式操作和-$\text{ogf}$">常用的形式操作和 <span class="markdown-them-math-inline">$\text{OGF}$</span></h2>
<p><img src="%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%9D%82%E8%AE%BA/gf_chitchat_1.png" alt="1"><br>
<img src="%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%9D%82%E8%AE%BA/gf_chitchat_2.png" alt="2"></p>
<p>下面我们将采用生成函数法求解一些经典问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="例题">例题</h2>
<h3 id="找零问题">找零问题</h3>
<blockquote>
<p>你有无穷多的 <span class="markdown-them-math-inline">$1$</span> 元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$2$</span> 元和 <span class="markdown-them-math-inline">$5$</span> 元的硬币<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>你需要支付 <span class="markdown-them-math-inline">$n$</span> 元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请问有多少种方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>我们设 <span class="markdown-them-math-inline">$F[n] =$</span> 支付 <span class="markdown-them-math-inline">$n$</span> 元的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特殊的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F[0] = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们用 <span class="markdown-them-math-inline">$\langle 1\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$\langle 2\rangle$</span> 与 <span class="markdown-them-math-inline">$\langle 5\rangle$</span> 分别表示三种面值的硬币<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们定义一种支付方案为一组硬币的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若一组硬币有 <span class="markdown-them-math-inline">$a$</span> 个 <span class="markdown-them-math-inline">$\langle 1\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$b$</span> 个 <span class="markdown-them-math-inline">$\langle 2\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$c$</span> 个 <span class="markdown-them-math-inline">$\langle 5\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则记作 <span class="markdown-them-math-inline">$\langle 1\rangle^a \langle 2\rangle^b \langle 5\rangle^c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一种支付方案的价值记为这种方案内硬币的价值总和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$value\left(\langle 1\rangle^a \langle 2\rangle^b \langle 5\rangle^c\right) = a + 2b + 5c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>定义两种支付方案 <span class="markdown-them-math-inline">$S_1, S_2$</span> 的乘法表示这两种支付方案同时支付<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意硬币在 <span class="markdown-them-math-inline">$S_1\times S_2$</span> 中被使用的次数是两边对应硬币幂次之和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这符合我们对幂的认知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时 <span class="markdown-them-math-inline">$value(S_1\times S_2) = value(S_1) + value(S_2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>定义两种支付方案 <span class="markdown-them-math-inline">$S_1, S_2$</span> 的加法表示这两种方案的并列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易验证乘法对加法有分配律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们采用无穷求和来表示所有可能的支付方式的并列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设我们只能支付 <span class="markdown-them-math-inline">$1$</span> 元的硬币<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则所有可能的支付方案可以表示为</p>
<p><div class="markdown-them-math-block">$$P_{\{1\}} = \varnothing + \langle 1 \rangle + \langle 1 \rangle^2  + \langle 1 \rangle^3 + \cdots = \frac{1}{1 - \langle 1 \rangle}$$</div></p>
<p>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们并不考虑代入一个值后的实际意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这只是表述支付方案的封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>随后我们加入 <span class="markdown-them-math-inline">$2$</span> 元的硬币<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这表示我们能够在每种方案中加入任意数量的 <span class="markdown-them-math-inline">$\langle 2 \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时的支付方案可以表示为</p>
<p><div class="markdown-them-math-block">$$P_{\{1,2\}} = \varnothing P_{\{1\}} + \langle 2 \rangle P_{\{1\}} + \langle 2 \rangle^2 P_{\{1\}}  + \langle 2 \rangle^3 P_{\{1\}} + \cdots = \left(\varnothing + \langle 2 \rangle + \langle 2 \rangle^2  + \langle 2 \rangle^3 + \cdots\right)  P_{\{1\}} = \frac{1}{1 - \langle 1 \rangle} \frac{1}{1 - \langle 2 \rangle}$$</div></p>
<p>类似地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们能得到加入 <span class="markdown-them-math-inline">$5$</span> 元硬币的答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$P_{\{1,2,5\}} = \frac{1}{1 - \langle 1 \rangle} \frac{1}{1 - \langle 2 \rangle}\frac{1}{1 - \langle 5 \rangle}$$</div></p>
<p>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$P_{\{1,2,5\}} \neq \sum_{k \ge 0}\left(\langle 1 \rangle + \langle 2 \rangle + \langle 5 \rangle\right)^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>若我们只关心总面值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以记 <span class="markdown-them-math-inline">$z^k$</span> 为一种面值和为 <span class="markdown-them-math-inline">$k$</span> 的方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$\langle 1 \rangle = z^1, \langle 2 \rangle = z^2, \langle 5\rangle = z^5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们的答案即为</p>
<p><div class="markdown-them-math-block">$$[z^n]\frac{1}{1 - z} \frac{1}{1 - z^2}\frac{1}{1 - z^5}$$</div></p>
<p>具体表出答案将用到分式分解的知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>留作读者练习<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p>首先需要对斐波那契数列进行定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>斐波那契数列是一个无穷数列 <span class="markdown-them-math-inline">$\langle f_i \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足<br>
<div class="markdown-them-math-block">$$f_0 = 0,\quad f_1 = 1,\quad f_n = f_{n - 1} + f_{n - 2}\ (i &gt; 1)$$</div></p>
<p>考虑斐波那契数列的 <span class="markdown-them-math-inline">$\text{OGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以通过一系列对生成函数系数的变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得所组合的新生成函数的任意一位可以通过原递归式表示变换前的生成函数对应位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>以  <span class="markdown-them-math-inline">$F(x)$</span> 为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
F(x) &amp;= &amp;f_0\ +\ &amp;f_1x\ + &amp;f_2x^2 + f_3x^3 + \cdots \\ 
xF(x) &amp;= &amp;\quad &amp;f_0x\ + &amp;f_1x^2 + f_2x^3 + \cdots \\
x^2F(x) &amp;= &amp;\quad &amp;\quad &amp; f_0x^2 + f_1x^3 + \cdots \\
\end{aligned}$$</div></p>
<p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$xF(x) + x^2F(x)$</span> 的系数正好对应 <span class="markdown-them-math-inline">$F(x)$</span> 中第二项及以后部分的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F(x)$</span> 满足<br>
<div class="markdown-them-math-block">$$F(x) = x + xF(x) + x^2 F(x)$$</div></p>
<p>等号右侧加入的 <span class="markdown-them-math-inline">$x$</span> 是修正系数用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>不难从如上的关系式中推得 <span class="markdown-them-math-inline">$F(x)$</span> 的封闭形式</p>
<p><div class="markdown-them-math-block">$$F(x) = \frac{x}{1 - x - x^2}$$</div></p>
<p>然而目前而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个封闭形式并未给我们提供有用的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要进一步地转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>举个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们想求得 <span class="markdown-them-math-inline">$f_n$</span> 仅使用 <span class="markdown-them-math-inline">$n$</span> 的表示法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即提取 <span class="markdown-them-math-inline">$F(x)$</span> 的第 <span class="markdown-them-math-inline">$n$</span> 项系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里我们仍然可以采用分式分解中的待定系数法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>具体地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们首先计算分母的因式分解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随后设未知数使 <span class="markdown-them-math-inline">$F(x)$</span> 被表示为两个简单分式的和的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后平凡地提取系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们可以解得 <span class="markdown-them-math-inline">$1 - x - x^2 = 0$</span> 的两个根 <span class="markdown-them-math-inline">$x_1 = \dfrac{-1 + \sqrt 5}{2}, x_2 = \dfrac{-1 - \sqrt 5}{2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>随后 <span class="markdown-them-math-inline">$F(x)$</span> 的分母就是 <span class="markdown-them-math-inline">$(x - x_1)(x - x_2)$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>随后我们设<br>
<div class="markdown-them-math-block">$$F(x) = \frac{a}{x - x_1} + \frac{b}{x - x_2}$$</div></p>
<p>这直接给出了方程组<br>
<div class="markdown-them-math-block">$$\left\{
\begin{aligned}&amp;a + b = 1\\
&amp;ax_1 + bx_2 = 0
\end{aligned
\right.$$</div></p>
<p>解得 <span class="markdown-them-math-inline">$a = \dfrac{5 + \sqrt 5}{10}, b = \dfrac{5 - \sqrt 5}{10}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>随后提取系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
[x^n] F(x) &amp; = [x^n]\frac{x}{1 - x - x^2}
\\ &amp; = [x^n]\left(\frac{a}{x - x_1} + \frac{b}{x - x_2}\right)
\\ &amp; = [x^n]\left(\frac{- a / x_1}{1 - x / x_1} + \frac{- b / x_2}{1 - x / x_2}\right)
\\ &amp; = -\left(\frac{a}{x_1^{n + 1}} + \frac{b}{x_2^{n + 1}}\right)
\end{aligned}$$</div></p>
<p>带入即可得到</p>
<p><div class="markdown-them-math-block">$$f_n = \frac{\sqrt 5}{5} \left(\left(\frac{1 + \sqrt 5}{2}\right) ^ n - \left(\frac{1 - \sqrt 5}{2}\right) ^ n\right)$$</div></p>
<p>此处同样可以应用不同根的有理展开定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对比 <span class="markdown-them-math-inline">$R(z)$</span> 的表达式可以发现 <span class="markdown-them-math-inline">$P(z) = z, Q(z) = 1 - z - z^2 = (1 - \phi z)(1 - \hat\phi z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$\phi,\hat\phi$</span> 为 <span class="markdown-them-math-inline">$Q^R(z) = z^2 - z - 1$</span> 的两个根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易得到 <span class="markdown-them-math-inline">$Q'(z) = -1 - 2z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\frac{-\rho P(1 / \rho)}{Q'(1 / \rho)} = \frac{-\rho (1 / \rho)}{-1 - 2 / \rho} =  \frac{-1}{-1 - 2 / \rho} = \frac{\rho}{\rho + 2}$$</div></p>
<p>根据定理 <span class="markdown-them-math-inline">$1.5.1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\phi$</span> 的系数就应当是 <span class="markdown-them-math-inline">$\dfrac{\phi}{\phi + 2} = \dfrac{1}{\sqrt 5}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$\hat\phi$</span> 的系数是 <span class="markdown-them-math-inline">$\dfrac{\hat\phi}{\hat\phi + 2} = \dfrac{-1}{\sqrt 5}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>带入得到<br>
<div class="markdown-them-math-block">$$f_n = \frac{\phi^n + \hat\phi^n}{\sqrt 5} = \frac{\sqrt 5}{5} \left(\left(\frac{1 + \sqrt 5}{2}\right) ^ n - \left(\frac{1 - \sqrt 5}{2}\right) ^ n\right)$$</div></p>
<h3 id="卡特兰数">卡特兰数</h3>
<p>我们定义卡特兰数 <span class="markdown-them-math-inline">$Cat(i)$</span> 如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$Cat(0) = 1, Cat(n) = n$</span> 对括号的合法匹配数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>三对括号时合法匹配有 <code>((()))</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>(()())</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>()()()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>()(())</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><code>(())()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$Cat(3) = 5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>想要通过生成函数刻画一个组合对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个经典的思路就是首先得到递推式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随后使用生成函数刻画对应的递推式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到递归构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终解出封闭形式或采用牛顿迭代法求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在本题中也不例外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们首先寻找卡特兰数满足的递推式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>寻找递推式的过程应当具体地结合组合对象自己的性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这点是无法总结归纳的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在本题中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以枚举新一对括号内的子括号序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在其外面放置合法的括号序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这也得到了</p>
<p><div class="markdown-them-math-block">$$Cat(n + 1) = \sum_{i=0}^n Cat(i)\times Cat(n - i)$$</div></p>
<p>构造卡特兰数的 <span class="markdown-them-math-inline">$\text{OGF } C(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现 <span class="markdown-them-math-inline">$Cat(n + 1) = [z^n]C^2(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里考虑 <span class="markdown-them-math-inline">$Cat(n + 1)$</span> 的 <span class="markdown-them-math-inline">$\text{OGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易发现其就是将零次项改为 <span class="markdown-them-math-inline">$0$</span> 后系数左移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是</p>
<p><div class="markdown-them-math-block">$$\frac{C(z) - 1}{z} = C^2(z)$$</div></p>
<p>这自然地导出了 <span class="markdown-them-math-inline">$C(z)$</span> 的封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$C(z) = \frac{1 \pm\sqrt{1 - 4z}}{2z}$$</div></p>
<p>这里发现出现了两个根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要讨论根的取舍问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然而由于数列是存在的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此必有一根可以取到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要判断哪个根满足显然的性质即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑 <span class="markdown-them-math-inline">$C(0) = [z^0]C(z) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$+$</span> 的情况取到正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不满足该性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们得到了</p>
<p><div class="markdown-them-math-block">$$C(z) = \frac{1 - \sqrt{1 - 4z}}{2z}$$</div></p>
<p>得到了封闭形式后提取系数就变得简便了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以直接应用广义二项式定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$(1 - 4z)^{1/2} = \sum_{i=0}^{\infty}\binom{1/2}{i}(-4z)^i = 1 + \sum_{i=1}^{\infty}\binom{1/2}{i}(-4z)^i$$</div></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
C(z) &amp; = \frac{1 - \sqrt{1 - 4z}}{2z}
\\ &amp; = \frac{1}{2z} \left(1 - 1 - \sum_{i=1}^{\infty}\binom{1/2}{i}(-4z)^i\right)
\\ &amp; = - \frac{1}{2z} \left(\sum_{i=1}^{\infty}\binom{1/2}{i}(-4z)^i\right)
\\ &amp; = 2 \sum_{i=1}^{\infty}\binom{1/2}{i}(-4z)^{i-1}
\\ &amp; = 2 \sum_{i=1}^{\infty}\frac{(1 / 2)^{\underline i}}{i!}(-4z)^{i-1}
\\ &amp; = 2 \sum_{i=1}^{\infty}\frac{(1/2)(-1/2)(-3/2)\cdots(3/2-i)}{i!}(-4z)^{i-1}
\\ &amp; = 2 \sum_{i=1}^{\infty}\frac{(1/2)(1/2)(3/2)\cdots(i - 3/2)}{i!}(4z)^{i-1}
\\ &amp; = \sum_{i=1}^{\infty}\frac{(1/2)(3/2)\cdots(i - 3/2)}{i!}(4z)^{i-1}
\\ &amp; = \sum_{i=1}^{\infty}\frac{(2i-3)!!}{i!}(2z)^{i-1}
\\ &amp; = \sum_{i=1}^{\infty}\frac{(2i-2)!}{i!(i-1)!}z^{i-1}
\\ &amp; = \sum_{i=0}^{\infty}\frac{(2i)!}{i!(i+1)!}z^i
\\ &amp; = \sum_{i=0}^{\infty}\frac{1}{i+ 1}\binom{2i}{i}z^i
\end{aligned}$$</div></p>
<p>这就得到了卡特兰数的经典形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="简析生成函数">简析生成函数</h2>
<h3 id="$\text{-ogf}$"><span class="markdown-them-math-inline">$\text{ OGF}$</span></h3>
<p><span class="markdown-them-math-inline">$\text{OGF}$</span> 正如它的名字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是最简单的构造一个序列的生成函数的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将每个元素加入以编号为幂次的占位元来区分每个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>两个 <span class="markdown-them-math-inline">$\text{OGF}$</span> 的乘法是经典的加卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>两个 <span class="markdown-them-math-inline">$\text{OGF}$</span> 之间的运算有着一系列的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/symbolic_method.html#-%E6%97%A0%E6%A0%87%E5%8F%B7%E4%BD%93%E7%B3%BB">组合意义</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
加法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在生成函数意义上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两个 <span class="markdown-them-math-inline">$\text{OGF}$</span> 的对应位置的值相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这表示着不相交的两个集合的并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>两个 <span class="markdown-them-math-inline">$\text{OGF}$</span> 对应位置代表着两个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而乘法就产生了这两个集合的笛卡尔积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即在这两个集合中分别选出一个组成二元组的全体对应的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{OGF}$</span> 的乘法和计数背包的合并是同构的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这也表明了 <span class="markdown-them-math-inline">$\text{OGF}$</span> 在处理组合问题上的代数意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>常见的 <span class="markdown-them-math-inline">$\text{OGF}$</span> 形式已于上方列出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="$\text{egf}$"><span class="markdown-them-math-inline">$\text{EGF}$</span></h3>
<p>考察 <span class="markdown-them-math-inline">$e^x$</span> 的麦克劳林级数形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们能够发现 <span class="markdown-them-math-inline">$\text{EGF}$</span> 得名的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个形式也为其处理排列问题提供了方便<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为其卷积能自然地拼凑出组合数的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$(F\times G)(x) = \sum_{k\ge 0} \sum_{i + j = k} \frac{F[i]x^i}{i!} \frac{G[j]x^j}{j!} = \sum_{k\ge 0} \sum_{i + j = k} \binom{k}{i} F[i] G[j] \frac{x^k}{k!} $$</div></p>
<p>这也表明了为何 <span class="markdown-them-math-inline">$\text{EGF}$</span> 更加适合应用于有标号有顺序对象的组合问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一组标号给一组对象只能产生一种情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为我们需要保证标号是有序的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们需要从这 <span class="markdown-them-math-inline">$i + j$</span> 个标号中选择 <span class="markdown-them-math-inline">$i$</span> 个标号给前一部分元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此得到一个系数 <span class="markdown-them-math-inline">$C_k^i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>两个 <span class="markdown-them-math-inline">$\text{EGF}$</span> 之间的运算有着一系列的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/symbolic_method.html#-%E6%9C%89%E6%A0%87%E5%8F%B7%E4%BD%93%E7%B3%BB">组合意义</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
加法仍然和 <span class="markdown-them-math-inline">$\text{OGF}$</span> 相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是不相交集合的并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在上面已经阐述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们产生两个集合的笛卡尔积时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应当考虑一次产生会出现多少不同标号的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将这一值作为系数加入乘积对应项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这也就是有标号对象对应集合的笛卡尔积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在这里需要介绍多项式指数函数施在 <span class="markdown-them-math-inline">$\text{EGF}$</span> 上的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们取一个 <span class="markdown-them-math-inline">$\text{EGF } F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其描述了一种有标号的组合元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$\exp F(x)$</span> 就描述了由这种组合元素构成的有标号集合的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有兴趣进一步了解的可以参阅<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/egf/#egf-%E4%B8%AD%E5%A4%9A%E9%A1%B9%E5%BC%8F-exp-%E7%9A%84%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89"> OI-Wiki 对这部分内容的讲解</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一些常见的 <span class="markdown-them-math-inline">$\text{EGF}$</span> 形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\langle 1, 1, 1, 1, 1, \cdots\rangle  \qquad &amp; \to \quad&amp; &amp;e^x \\
\langle 1, -1, 1, -1, 1, \cdots\rangle \qquad &amp; \to \quad &amp; &amp;e^{-x} \\
\langle 1, 0, 1, 0, 1, \cdots\rangle \qquad &amp; \to \quad &amp; &amp;\frac{e^x + e^{-x}}{2} \\
\langle 1, c, c^2, c^3, c^4, \cdots\rangle \qquad &amp; \to \quad &amp; &amp;e^{cx} \\
\langle 1, a, a^{\underline 2}, a^{\underline 3}, a^{\underline 4}, \cdots\rangle \qquad &amp; \to \quad &amp; &amp;(1 + x)^a
\end{aligned}$$</div></p>
<p>实现时处理 <span class="markdown-them-math-inline">$\text{EGF}$</span> 常将 <span class="markdown-them-math-inline">$x^k$</span> 和 <span class="markdown-them-math-inline">$1/k!$</span> 分开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后者作为 <span class="markdown-them-math-inline">$x^k$</span> 系数的一部分储存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此在提取 <span class="markdown-them-math-inline">$[x^n/n!]$</span> 项系数时应当改作提取 <span class="markdown-them-math-inline">$[x^n]$</span> 项系数的 <span class="markdown-them-math-inline">$n!$</span> 倍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="$\text{dgf}$"><span class="markdown-them-math-inline">$\text{DGF}$</span></h3>
<p><span class="markdown-them-math-inline">$\text{DGF}$</span> 的特殊构造和其名字有着密不可分的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其是被专门构造来处理数论函数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>两个 <span class="markdown-them-math-inline">$\text{DGF}$</span> 之间的乘法有着一系列的数论意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们能看到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两个数论函数的 <span class="markdown-them-math-inline">$\text{DGF}$</span> 的乘积是两者的狄利克雷卷积对应的 <span class="markdown-them-math-inline">$\text{DGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$(F\times G)(z) = \sum_{i\ge 1}\sum_{j \ge 1} \frac{F[i]}{i^z} \frac{G[j]}{j^z} = \sum_{i\ge 1}\sum_{j \ge 1} \frac{F[i]G[j]}{(ij)^z} = \sum_{i\ge 1}\left(\sum_{d|i} F[d]G\left[\frac{i}{d}\right]\right)\frac{1}{i^z}$$</div></p>
<p>如果一个 <span class="markdown-them-math-inline">$\text{DGF } F(x)$</span> 对应着一个积性函数 <span class="markdown-them-math-inline">$f(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则该 <span class="markdown-them-math-inline">$\text{DGF}$</span> 可以被 <span class="markdown-them-math-inline">$f$</span> 在质数幂次处的取值表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$\mathbb P$</span> 为质数集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有</p>
<p><div class="markdown-them-math-block">$$F(x) = \prod_{p\in \mathbb P} \left(1 + \frac{f(p)}{p^x} +  \frac{f(p^2)}{p^{2x}} + \frac{f(p^3)}{p^{3x}} \cdots\right)$$</div></p>
<p>可以应用它证明一些结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或是构造一些筛法的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>相关的应用可以类比<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/chitchat221217.html">贝尔级数</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="二元生成函数">二元生成函数</h2>
<p>以二元生成函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\underline{\textbf{B}}\text{ivariate} \ \underline{\textbf{G}}\text{enerating} \ \underline{\textbf{F}}\text{unction}, \ \text{BGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>为主的多占位元生成函数是为了分析多维序列而构造的一类生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其与一元生成函数不同之处在于其存在多个占位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别用于标识不同变量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>本文将以二元生成函数为例探讨多占位元生成函数的应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 2.5.1 }\text{(二元生成函数)}$</span></p>
<p>对于一个无穷序列 <span class="markdown-them-math-inline">$\langle a_{i, j}\rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义其关于占位元 <span class="markdown-them-math-inline">$k_i(x), k_j(y)$</span> 的二元生成函数 <span class="markdown-them-math-inline">$G(x, y)$</span> 如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$G(x, y) = \sum_{i = 0}^{\infty}\sum_{j = 0}^{\infty} a_{i, j} k_i(x) k_j(y)$$</div></p>
</blockquote>
<p>这里 <span class="markdown-them-math-inline">$k_i(x),k_j(y)$</span> 不一定是同一类占位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应用见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/chitchat230129.html">小孩召开法</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>二元生成函数在实际计数问题中常用于标识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>恰好选 <span class="markdown-them-math-inline">$k$</span> 个组合元素<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设我们构造了一个组合元素的 <span class="markdown-them-math-inline">$\text{EGF } F(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那如果我们需要恰好 <span class="markdown-them-math-inline">$m$</span> 个组合元素中 <span class="markdown-them-math-inline">$n$</span> 个最小的单元组成的对象的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以直接做 <span class="markdown-them-math-inline">$[x^ny^m / n!]\exp(F(x)y)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/editorchat221215.html">[PA 2019 Final] Grafy</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>另外的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以头铁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在使用诸如解二元微分方程组的方式后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>能得到一个二元生成函数的封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以借助一些组合或配凑的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将占位元各个击破<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后得到最简单的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/chitchat221228.html">本篇闲话中的方法 2</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<hr>
<blockquote>
<p>解析组合试图从一个较为机械化的方式帮助我们将组合计数问题从模型直接转为生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div align="right">—— $\text{EntropyIncreaser}$</div>
</blockquote>
<p>解析组合为我们提供了一套能处理一系列组合结构计数和渐进估计的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分为解析和组合两个部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
解析的部分主要讨论了如何近似生成函数的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而组合的部分则着眼于操作组合结构以便计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>符号化方法就是组合部分中操作组合结构的一种机械方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过描述组合结构来声明对应的生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过这种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以跳过转移方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接写出生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也能够得到关于生成函数和组合意义的联系的更深刻理解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="无标号体系">无标号体系</h1>
<h2 id="记号与定义">记号与定义</h2>
<p>组合对象是满足某一性质的可数对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>烯烃或字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>组合类是一系列组合对象组成的可数集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
下面将采用美术花体<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>\mathcal</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>大写字母表示一个组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>每个组合类 <span class="markdown-them-math-inline">$\mathcal A$</span> 都定义了一个大小函数 <span class="markdown-them-math-inline">$f: \mathcal A\to \mathbb N$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足对任何 <span class="markdown-them-math-inline">$k\in \mathbb N$</span> 只有有限个组合对象 <span class="markdown-them-math-inline">$a\in \mathcal A$</span> 满足 <span class="markdown-them-math-inline">$f(a) = k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$f(a)$</span> 表示了组合对象 <span class="markdown-them-math-inline">$a$</span> 的固有属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能是树高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>节点数或串长等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>常记 <span class="markdown-them-math-inline">$f(a)$</span> 为 <span class="markdown-them-math-inline">$\lvert a\rvert$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在某些需要指明组合类的场合下记作 <span class="markdown-them-math-inline">$\lvert a \rvert_{\mathcal A}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们将 <span class="markdown-them-math-inline">$a\in \mathcal A \text{ s.t. } \lvert a \rvert = n$</span> 的全体记作 <span class="markdown-them-math-inline">$\mathcal A_n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并以此构造一个计数序列 <span class="markdown-them-math-inline">$A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$A[n] = \lvert \mathcal A_n\rvert$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
两个组合类 <span class="markdown-them-math-inline">$\mathcal A, \mathcal B$</span> 在组合意义上同构记作 <span class="markdown-them-math-inline">$\mathcal A = \mathcal B$</span> 或 <span class="markdown-them-math-inline">$\mathcal A \cong \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但仅在 <span class="markdown-them-math-inline">$\mathcal A$</span> 和 <span class="markdown-them-math-inline">$\mathcal B$</span> 不同构时才用后一种记号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们在描述组合对象时只会关注我们需要的单一性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种抽象有助于我们理解下文中将不同对象组合为新的对象的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>总的来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们忽视组合对象除了<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>外的所有信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样很多组合操作都可以被简单地映射在<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>并列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>操作上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一个组合类 <span class="markdown-them-math-inline">$\mathcal A$</span> 的 <span class="markdown-them-math-inline">$\text{OGF}$</span> 即其对应的计数序列 <span class="markdown-them-math-inline">$A$</span> 的 <span class="markdown-them-math-inline">$\text{OGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为一个形式幂级数</p>
<p><div class="markdown-them-math-block">$$A(z) = \sum_{i\ge 0} A[i] z^i$$</div></p>
<p>它也可以被等价地写作</p>
<p><div class="markdown-them-math-block">$$A(z) = \sum_{a\in \mathcal A} z^{\lvert a \rvert}$$</div></p>
<p>我们称 <span class="markdown-them-math-inline">$z^{\lvert a \rvert}$</span> 为 <span class="markdown-them-math-inline">$a$</span> 的幂表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里的 <span class="markdown-them-math-inline">$z$</span> 仍然只是占位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>由以上内容不难验证组合类的笛卡尔积和 <span class="markdown-them-math-inline">$\text{OGF}$</span> 的乘法 <span class="markdown-them-math-inline">$\times$</span> 同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>集合不交并和 <span class="markdown-them-math-inline">$\text{OGF}$</span> 的加法 <span class="markdown-them-math-inline">$+$</span> 同构<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>处理了重复元素的加法会在下方重新定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
下面对集合的笛卡尔积也记作 <span class="markdown-them-math-inline">$\times$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>集合并也记作 <span class="markdown-them-math-inline">$+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>组合类都是由一些更本质的组合类构造出来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>一个构造是从一组组合类映射到一个组合类的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
当我们说一个构造可以被翻译为生成函数运算时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们想要表达的就是这种组合类间的映射能和生成函数间的运算对应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个经典的例子是 <a target="_blank" rel="noopener" href="https://oi-wiki.org/math/poly/egf/#egf-%E4%B8%AD%E5%A4%9A%E9%A1%B9%E5%BC%8F-exp-%E7%9A%84%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89"><span class="markdown-them-math-inline">$\exp$</span> 的组合意义</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>下文中还会有更多类似的例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下文中需要对某些表性相似的元素加以合并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此在这里引入等价关系和等价类的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于组合类 <span class="markdown-them-math-inline">$\mathcal A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设其中任意对象都是 <span class="markdown-them-math-inline">$\mathcal B$</span> 中某些对象的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们定义 <span class="markdown-them-math-inline">$a\in \mathcal A$</span> 对 <span class="markdown-them-math-inline">$\mathcal B$</span> 的拆分为 <span class="markdown-them-math-inline">$a = (b_1, b_2, \dots, b_m), \forall b_i \in \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这拆分一般应当是唯一的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$a$</span> 在 <span class="markdown-them-math-inline">$\mathcal B$</span> 上的容为 <span class="markdown-them-math-inline">$\text{cap}_{\mathcal B}(a) = m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即拆分中的元素个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义一个等价关系是一个置换群列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用加粗大写字母<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>\textbf</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$\textbf G$</span> 是一个置换群列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以记 <span class="markdown-them-math-inline">$\textbf G = \{G_0, G_1, G_2,\dots\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$G_k$</span> 是一个置换群<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足任意 <span class="markdown-them-math-inline">$g\in G_k$</span> 都是一个大小为 <span class="markdown-them-math-inline">$k$</span> 的元素上的置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若一个等价关系 <span class="markdown-them-math-inline">$\textbf G$</span> 是针对组合类 <span class="markdown-them-math-inline">$\mathcal A$</span> 中元素对 <span class="markdown-them-math-inline">$\mathcal B$</span> 的拆分定义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则称 <span class="markdown-them-math-inline">$\textbf G$</span> 以 <span class="markdown-them-math-inline">$\mathcal B$</span> 为拆分集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$\textbf G_{\mathcal B}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义 <span class="markdown-them-math-inline">$a_1, a_2$</span> 对 <span class="markdown-them-math-inline">$\mathcal B$</span> 的拆分在 <span class="markdown-them-math-inline">$\textbf G$</span> 上等价<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>本质相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>当且仅当</p>
<ol>
<li><span class="markdown-them-math-inline">$\text{cap}_{\mathcal B}(a_1) = \text{cap}_{\mathcal B}(a_2)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$\exists g\in G_{\text{cap}_{\mathcal B}(a_1)}, g(a_1) = a_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>注意这里 <span class="markdown-them-math-inline">$g$</span> 的作用是将 <span class="markdown-them-math-inline">$a_1$</span> 的拆分重排<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
下面常将两个拆分 <span class="markdown-them-math-inline">$(a_1, a_2, \dots a_n)$</span> 和 <span class="markdown-them-math-inline">$(b_1, b_2, \dots, b_n)$</span> 在 <span class="markdown-them-math-inline">$\textbf G$</span> 上等价记作 <span class="markdown-them-math-inline">$(a_1, a_2, \dots a_n)\textbf G(b_1, b_2, \dots, b_n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下文中也会以下标变换的方式说明对应的 <span class="markdown-them-math-inline">$g\in G_n$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于组合类 <span class="markdown-them-math-inline">$\mathcal A$</span> 和等价关系 <span class="markdown-them-math-inline">$\textbf G$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取一个 <span class="markdown-them-math-inline">$\mathcal A$</span> 的子集 <span class="markdown-them-math-inline">$\mathcal S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\mathcal S$</span> 中任意两个对象等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且任意 <span class="markdown-them-math-inline">$\mathcal S$</span> 中对象和 <span class="markdown-them-math-inline">$\complement_{\mathcal A}\mathcal S$</span> 中对象不等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们称 <span class="markdown-them-math-inline">$\mathcal S$</span> 是 <span class="markdown-them-math-inline">$\textbf G$</span> 下的等价类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>常记 <span class="markdown-them-math-inline">$\lvert \mathcal S\rvert$</span> 为等价类中一个元素的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般等价类中任意组合对象大小相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于组合类 <span class="markdown-them-math-inline">$\mathcal A$</span> 和等价关系 <span class="markdown-them-math-inline">$\textbf G_{\mathcal B}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义 <span class="markdown-them-math-inline">$\mathcal A / \textbf G_{\mathcal B}$</span> 得到了一个新的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足任意原等价类在新的组合类中有且仅有一个元素作为代表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>这里常取在某一性质<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>例如字典序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>下最小元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有时也定义新的组合类中的对象是原组合类中的等价类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即新组合类是<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>组合类的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在下面对组合类的构造过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新组合类的对象常对原组合类进行拆分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此在语义明显时不声明原组合类为等价关系的拆分集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="基础无标号类">基础无标号类</h2>
<p>下面引入两种特殊的组合对象和对应的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们记 <span class="markdown-them-math-inline">$\epsilon$</span> 为中性对象<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>neutral object<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对应的组合类记作 <span class="markdown-them-math-inline">$\mathcal E = \{\epsilon \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称作中性类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>neutral class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
恒有 <span class="markdown-them-math-inline">$\lvert \epsilon \rvert = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有中性类的 <span class="markdown-them-math-inline">$\text{OGF}$</span> <span class="markdown-them-math-inline">$E(z) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两个中性对象 <span class="markdown-them-math-inline">$\epsilon_1, \epsilon_2$</span> 可能不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记一个下标为 <span class="markdown-them-math-inline">$k$</span> 的中性对象 <span class="markdown-them-math-inline">$\epsilon_k$</span> 对应的类为 <span class="markdown-them-math-inline">$\mathcal E_k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们有<br>
<div class="markdown-them-math-block">$$\mathcal A  \cong \mathcal E\times \mathcal A  \cong \mathcal A\times \mathcal E$$</div><br>
对于任意组合类 <span class="markdown-them-math-inline">$\mathcal A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>规定 <span class="markdown-them-math-inline">$\mathcal A^0 = \mathcal E$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是由于组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal E$</span> 不能视作笛卡尔积的单位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>定义了中性对象后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以定义不需要考虑交集的集合并了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于集合论中需要满足集合内无重合元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以对两个类分别乘上不同的中性类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样两个类中可能相同的对象在并集中也彼此不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们定义两个类 <span class="markdown-them-math-inline">$\mathcal A, \mathcal B$</span> 的集合并 <span class="markdown-them-math-inline">$\mathcal A + \mathcal B$</span> 为</p>
<p><div class="markdown-them-math-block">$$(\mathcal E_1 \times \mathcal A) \cup (\mathcal E_2 \times \mathcal B)$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$\cup$</span> 为集合的不交并<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们记 <span class="markdown-them-math-inline">$\bullet$</span> 为原子对象<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>atom object<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对应的组合类记作 <span class="markdown-them-math-inline">$\mathcal Z = \{\bullet \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称作原子类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>atom class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
恒有 <span class="markdown-them-math-inline">$\lvert \bullet \rvert = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有原子类的 <span class="markdown-them-math-inline">$\text{OGF}$</span> <span class="markdown-them-math-inline">$Z(z) = z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
原子对象常用于合并数个组合对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>经典例子是作为树的根出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="例题-1">例题</h2>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>01 串</p>
<blockquote>
<p>我们如何求得长度为 <span class="markdown-them-math-inline">$n$</span> 的 01 串的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
</blockquote>
<p>设 01 串的组合类为 <span class="markdown-them-math-inline">$\mathcal S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们要求的就是 <span class="markdown-them-math-inline">$\lvert\mathcal S_n\rvert$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以写出</p>
<p><div class="markdown-them-math-block">$$\mathcal S = \{ \epsilon, \mathtt{0}, \mathtt{1}, \mathtt{00}, \mathtt{01}, \mathtt{10}, \mathtt{11}, \mathtt{000},\dots \}$$</div></p>
<p>对于某个 01 串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其要么为空串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么是 <span class="markdown-them-math-inline">$\mathtt{0},\mathtt{1}$</span> 接在另一个 01 串前面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以写出</p>
<p><div class="markdown-them-math-block">$$\mathcal S = \mathcal E + \{ \mathtt{0}, \mathtt{1} \}\times \mathcal S$$</div></p>
<p>翻译成生成函数就是 <span class="markdown-them-math-inline">$S(z) = 1 + (z + z) S(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就能得到 <span class="markdown-them-math-inline">$S(z) = \dfrac{1}{1 - 2z}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>答案即为 <span class="markdown-them-math-inline">$[z^n]S(z) = 2^n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>卡特兰数</p>
<blockquote>
<p>我们如何构造长度为 <span class="markdown-them-math-inline">$n$</span> 的生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
</blockquote>
<p>卡特兰数有一个很经典的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$Cat(n)$</span> 是 <span class="markdown-them-math-inline">$n$</span> 个点的二叉树个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于一棵二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它要么为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么形如 <span class="markdown-them-math-inline">$左子树-根-右子树$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>根可以视作 <span class="markdown-them-math-inline">$\bullet$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>两侧则又是二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
假设二叉树的组合类为 <span class="markdown-them-math-inline">$\mathcal C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以写出</p>
<p><div class="markdown-them-math-block">$$\mathcal C = \mathcal E + \mathcal C \times \mathcal Z \times \mathcal C$$</div></p>
<p>翻译成生成函数就是 <span class="markdown-them-math-inline">$C(z) = 1 + zC(z)^2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这和我们先前得到的形式相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="经典的无标号构造">经典的无标号构造</h1>
<h2 id="集合的-$\text{sequence}$ 构造">集合的 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造生成了所有可能的有序组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义</p>
<p><div class="markdown-them-math-block">$$\text{SEQ}(\mathcal A) = \mathcal E + \mathcal A + \left(\mathcal A \times \mathcal A\right) + \left(\mathcal A \times \mathcal A \times \mathcal A\right) + \cdots$$</div></p>
<p>且要求 <span class="markdown-them-math-inline">$\mathcal A_0 = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是 <span class="markdown-them-math-inline">$\mathcal A$</span> 中没有大小为 <span class="markdown-them-math-inline">$0$</span> 的对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们还可以将这构造生成的组合类写作</p>
<p><div class="markdown-them-math-block">$$\text{SEQ}(\mathcal A) = \left\{\left(\beta_1, \beta_2, \dots, \beta_k\right) | k\ge 0, \beta_i \in \mathcal A\right\}$$</div></p>
<p>这映射翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$Q(A(z)) = 1 + A(z) + A^2(z) + A^3(z) + \cdots = \frac{1}{1 - A(z)}$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$Q$</span> 为 Pólya 准逆<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>quasi-inversion<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>写出 <span class="markdown-them-math-inline">$\{\text{a}, \text{b}\}$</span> 的 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}&amp;\text{SEQ}(\left\{\text{a}, \text{b}\right\})
\\ = \ &amp; \quad \  \{\epsilon\} + \{\text{a}\} + \{\text{b}\} + \{\text{a} \text{b}\} + \{\text{b} \text{a}\} 
\\ &amp; + \{\text{aaa}\} + \{\text{aab}\} +  \{\text{aba}\} +  \{\text{abb}\}
\\ &amp; + \{\text{baa}\} + \{\text{bab}\} +  \{\text{bba}\} +  \{\text{bbb}\}
\\ &amp; + \cdots
\end{aligned}$$</div></p>
<p><span class="markdown-them-math-inline">$\textbf{例 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有序有根树计数</p>
<p>我们可以使用 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造来定义有序有根树<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不同儿子之间的顺序有意义的有根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>设对应的组合类是 <span class="markdown-them-math-inline">$\mathcal T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以用一个原子对象和自身的 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 描述自身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是</p>
<p><div class="markdown-them-math-block">$$\mathcal T = \mathcal Z\times \text{SEQ}(\mathcal T)$$</div></p>
<p>翻译为生成函数就是</p>
<p><div class="markdown-them-math-block">$$T(z) = \frac{z}{1 - T(z)}$$</div></p>
<p>从这里也可以看出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$T(z) = \dfrac{1 - \sqrt{1 - 4z}}{2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此大小为 <span class="markdown-them-math-inline">$n$</span> 的有序有根树的大小为移位的卡特兰数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="集合的-$\text{multiset}$ 构造">集合的 <span class="markdown-them-math-inline">$\text{Multiset}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Multiset}$</span> 构造生成了所有可能的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不区分对象内部的元素的顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们仍然可以使用 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造描述 <span class="markdown-them-math-inline">$\text{Multiset}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是由于顺序原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以递推解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次只拿出一个元素作 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$\mathcal A = \left\{\alpha_0, \alpha_1, \dots, \alpha_k \right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以递推地作 <span class="markdown-them-math-inline">$\text{MSET}$</span> 构造如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\text{MSET}(\left\{\alpha_0, \alpha_1, \dots, \alpha_k \right\}) = \text{MSET}(\left\{\alpha_0, \alpha_1, \dots, \alpha_{k - 1} \right\})\times \text{SEQ}(\left\{\alpha_k\right\})$$</div></p>
<p>即</p>
<p><div class="markdown-them-math-block">$$\text{MSET}(\mathcal A) = \prod_{\alpha \in \mathcal A} \text{SEQ}(\{\alpha\})$$</div></p>
<p>且要求 <span class="markdown-them-math-inline">$\mathcal A_0 = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以得到等价的</p>
<p><div class="markdown-them-math-block">$$\text{MSET}(\mathcal A) = \text{SEQ}(\mathcal A) / \textbf R$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$(a_1, a_2, \dots, a_n)\textbf{R}(b_1, b_2, \dots, b_n)$</span> 当且仅当存在一个置换 <span class="markdown-them-math-inline">$\sigma$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于任意 <span class="markdown-them-math-inline">$j$</span> 满足 <span class="markdown-them-math-inline">$b_j = a_{\sigma(j)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>翻译为生成函数就是</p>
<p><div class="markdown-them-math-block">$$\text{Exp}(A(z)) = \prod_{\alpha \in \mathcal A} \left( 1 - z^{\lvert\alpha\rvert} \right)^{-1} = \prod_{i\ge 1} (1 - z^i)^{- A[i]}$$</div></p>
<p>作 <span class="markdown-them-math-inline">$\ln - \exp$</span> 可以得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp;\text{Exp}(A(z)) 
\\ = \ &amp; \exp\left(  \sum_{i\ge 1} - A[i] \ln(1 - z^i) \right)
\\ = \ &amp; \exp\left(  \sum_{i\ge 1} - A[i] \sum_{j\ge 1} \frac{-z^{ij}}{j} \right)
\\ = \ &amp; \exp\left(  \sum_{j\ge 1} \frac{1}{j} \sum_{i\ge 1} A[i] (z^{j})^{i} \right)
\\ = \ &amp; \exp\left(  \sum_{j\ge 1} \frac{A(z^j)}{j} \right)
\end{aligned}$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$\text{Exp}$</span> 被称作为 Pólya 指数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又称 Euler 变换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://loj.ac/p/6268">整数的分拆</a></p>
<blockquote>
<p>对每个 <span class="markdown-them-math-inline">$1\le i \le 10^5$</span> 求 <span class="markdown-them-math-inline">$f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$f(k)$</span> 是将 <span class="markdown-them-math-inline">$k$</span> 进行分拆的方案数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>设全体正整数类为 <span class="markdown-them-math-inline">$\mathcal I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现</p>
<p><div class="markdown-them-math-block">$$\mathcal I = \text{SEQ}_{\ge 1}(\mathcal Z) = \mathcal Z \times \text{SEQ}(\mathcal Z)$$</div></p>
<p><span class="markdown-them-math-inline">$\text{SEQ}_{\ge 1}$</span> 是有限制的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在下方讲到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当然求上面的东西对答案没啥帮助<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以直接构造 <span class="markdown-them-math-inline">$I(z) = \sum_{i\ge 1} z^i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
所求的就是 <span class="markdown-them-math-inline">$\text{MSET}(\mathcal I)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5900">无标号无根树计数</a></p>
<blockquote>
<p>我们能否对无标号无根树的计数构造生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
</blockquote>
<p>假设无标号有根树的组合类是 <span class="markdown-them-math-inline">$\mathcal T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以写出</p>
<p><div class="markdown-them-math-block">$$\mathcal T = \mathcal Z \times \text{MSET}(\mathcal T)$$</div></p>
<p>也就是</p>
<p><div class="markdown-them-math-block">$$T(z) = z\times \text{Exp}(T(z))$$</div></p>
<p>对于无根的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>论文 <a target="_blank" rel="noopener" href="https://users.math.msu.edu/users/magyarp/Math482/Otter-Trees.pdf">The Number of Trees, Richard Otter</a> 说明了无根树的 <span class="markdown-them-math-inline">$\text{OGF}$</span> 是</p>
<p><div class="markdown-them-math-block">$$T(z) - \frac{1}{2} T^2(z) + \frac{1}{2} T(z^2)$$</div></p>
<p>这点也可以通过对奇偶次项系数进行不同的讨论得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个数列即为 <a target="_blank" rel="noopener" href="https://oeis.org/A000055">A55</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 3}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3784">Pólya 指数的逆变换</a></p>
<blockquote>
<p>我们能否根据 <span class="markdown-them-math-inline">$\text{Exp}$</span> 的结构得到它的逆变换<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不考虑常数项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
</blockquote>
<p>记给定幂级数为 <span class="markdown-them-math-inline">$F(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们需要求的就是一个序列 <span class="markdown-them-math-inline">$A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足</p>
<p><div class="markdown-them-math-block">$$F(z) = \prod_{i \ge 1} (1 - z^i)^{-A[i]}$$</div></p>
<p>两边取对数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\ln F(z) &amp; = \sum_{i \ge 1} - A[i] \ln(1 - z^i) \\
&amp; = \sum_{i \ge 1} A[i] \sum_{j\ge 1} \frac{z^{ij}}{j} \\
&amp; = \sum_{T\ge 1} z^{T} \sum_{d | T} \frac{d}{T} A[d]
\end{aligned}$$</div></p>
<p>记 <span class="markdown-them-math-inline">$\ln F(z)$</span> 为 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以发现</p>
<p><div class="markdown-them-math-block">$$f[T] = \frac{1}{T}\sum_{d|T} d A[d]$$</div></p>
<p>作莫比乌斯反演得到</p>
<p><div class="markdown-them-math-block">$$A[T] = \frac{1}{T} \sum_{d|T} df[d] \times\mu\left(\frac{T}{d}\right)$$</div></p>
<p>这就是逆运算的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="集合的-$\text{powerset}$ 构造">集合的 <span class="markdown-them-math-inline">$\text{Powerset}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Powerset}$</span> 构造生成了所有可能的子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个元素我们都可以选或不选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这会导出两类不同的子集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此我们可以递归地定义 <span class="markdown-them-math-inline">$\text{PSET}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\text{PSET}(\left\{\alpha_0, \alpha_1, \dots, \alpha_k \right\}) = \text{PSET}(\left\{\alpha_0, \alpha_1, \dots, \alpha_{k - 1} \right\})\times (\mathcal E + \left\{\alpha_k\right\})$$</div></p>
<p>可以写作</p>
<p><div class="markdown-them-math-block">$$\text{PSET}(\mathcal A) \cong \prod_{\alpha \in \mathcal A} (\mathcal E + \{\alpha\})$$</div></p>
<p>要求 <span class="markdown-them-math-inline">$\mathcal A_0 = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>容易发现 <span class="markdown-them-math-inline">$\text{PSET}(\mathcal A)\subset \text{MSET}(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 <span class="markdown-them-math-inline">$\mathcal E + \{\alpha\} = \text{SEQ}_{k\le 1}(\{\alpha\})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>翻译为生成函数就是</p>
<p><div class="markdown-them-math-block">$$\overline{\text{Exp}}(A(z)) = \prod_{i\ge 1} (1 - z^i)^{A[i]} = \exp\left( \sum_{i \ge 1} (-1)^{i + 1} \frac{A(z^i)}{i} \right)$$</div></p>
<h2 id="集合的-$\text{amplification}$ 构造">集合的 <span class="markdown-them-math-inline">$\text{Amplification}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Amplification}$</span> 构造生成了所有可能的并列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们可以如此定义 <span class="markdown-them-math-inline">$\text{AMP}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\text{AMP}(\mathcal A) = \bigcup_{\alpha \in \mathcal A} \text{SEQ}(\{ \alpha \})$$</div></p>
<p>要求 <span class="markdown-them-math-inline">$\mathcal A_0 = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意多个 <span class="markdown-them-math-inline">$\mathcal A$</span> 中的元素 <span class="markdown-them-math-inline">$\alpha$</span> 自身的并列组成了 <span class="markdown-them-math-inline">$\text{AMP}(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>翻译成生成函数就是</p>
<p><div class="markdown-them-math-block">$$\sum_{i\ge 0} A(z^i)$$</div></p>
<h2 id="集合的-$\text{cycle}$ 构造">集合的 <span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造生成了所有可能的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不区分仅轮换不同的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义这个构造为</p>
<p><div class="markdown-them-math-block">$$\text{CYC}(\mathcal A) = \left(\text{SEQ}(\mathcal A)\ \backslash\ \mathcal E\right) / \textbf S$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$\textbf S$</span> 为等价关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$(a_1, a_2, \dots a_n) \textbf S(b_1, b_2, \dots, b_n)$</span> 当且仅当存在循环移位 <span class="markdown-them-math-inline">$\tau$</span> 使得对于任意 <span class="markdown-them-math-inline">$j$</span> 有 <span class="markdown-them-math-inline">$b_j = a_{\tau(j)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>翻译为生成函数是</p>
<p><div class="markdown-them-math-block">$$\text{Log}(A(z)) = \sum_{k\ge 1} \frac{\varphi(k)}{k} \ln \frac{1}{1 - A(z^k)}$$</div></p>
<p><span class="markdown-them-math-inline">$\text{Log}$</span> 被称作为 Pólya 对数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>公式的证明可以参见 <a target="_blank" rel="noopener" href="https://epubs.siam.org/doi/10.1137/0404006">The Cycle Construction, P. Flajolet and M. Soria</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里不再展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>采用群论相关知识我们也可以获得相同的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>列举 <span class="markdown-them-math-inline">$\text{CYC}(\{\text{a}, \text{b}\})$</span> 中长度为 <span class="markdown-them-math-inline">$4$</span> 的对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>它们分别为</p>
<p><div class="markdown-them-math-block">$$\text{aaaa}, \text{aaab}, \text{aabb}, \text{abbb}, \text{bbbb}, \text{abab}$$</div></p>
<p>由于 <span class="markdown-them-math-inline">$\text{aaab}\textbf S\text{aaba}\textbf S\text{abaa}\textbf S\text{baaa}, \text{aabb}\textbf S\text{abba}\textbf S\text{bbaa}\textbf S\text{baab},  \text{abbb}\textbf S\text{bbba}\textbf S\text{bbab}\textbf S\text{babb}, \text{abab}\textbf S\text{baba}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这几个等价类都只有一个元素出现在 <span class="markdown-them-math-inline">$\text{CYC}(\{\text{a}, \text{b}\})$</span> 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里采用字典序最小的字符串作为代表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="有限制的构造">有限制的构造</h2>
<p>对于上述构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们并没有限制每个对象组成部分的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
这里以 <span class="markdown-them-math-inline">$\text{SEQ}$</span> 构造为例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们若在 <span class="markdown-them-math-inline">$\text{SEQ}$</span> 的下标加上作用于整数的谓词用于约束其组成部分的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 <span class="markdown-them-math-inline">$\text{SEQ}_{= k}, \text{SEQ}_{\ge k}, \text{SEQ}_{\in [1, k]}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示构造出的等价类中每个对象的拆分中相同元素需要被下标上对应的谓词限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>常简写 <span class="markdown-them-math-inline">$\text{SEQ}_{= k}$</span> 为 <span class="markdown-them-math-inline">$\text{SEQ}_{k}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>令一个构造 <span class="markdown-them-math-inline">$\text{CONS}$</span> 为上述构造中的一种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并设 <span class="markdown-them-math-inline">$\mathcal A = \text{CONS}_k(\mathcal B)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们需要对 <span class="markdown-them-math-inline">$\forall \alpha \in \mathcal A$</span> 有 <span class="markdown-them-math-inline">$\alpha = \left\{(\beta_1, \beta_2, \dots, \beta_k) \mid \forall \beta_i \in \mathcal B \right\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这种构造我们在先前已经充分接触过了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其翻译到生成函数上就是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/poly-and-gf.html#-%E4%BA%8C%E5%85%83%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0">用新占位元来标识组成部分的个数</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
组合意义上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义 <span class="markdown-them-math-inline">$\chi$</span> 函数作用于一个元素上标识其组成部分的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是它需要被对应的逻辑谓词限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>用在上面的例子上就是 <span class="markdown-them-math-inline">$\chi(\alpha) = k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>延续先前的记号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令</p>
<p><div class="markdown-them-math-block">$$\mathcal A_{n, k} = \left\lvert \left\{  \alpha \in \mathcal A \mid \lvert\alpha\rvert = n, \chi(\alpha) = k \right\} \right\rvert$$</div></p>
<p>翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$A(z, t) = \sum_{n\ge 0} \sum_{k\ge 0} \mathcal A_{n, k} z^n t^k = \sum_{\alpha \in \mathcal A} z^{\lvert \alpha \rvert} t^{\chi(\alpha)}$$</div></p>
<p>我们只需要提取 <span class="markdown-them-math-inline">$t^k$</span> 项系数即可得到对应的表达式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对应 <span class="markdown-them-math-inline">$\text{SEQ}_k$</span> 就能得到</p>
<p><div class="markdown-them-math-block">$$A(z, t) = \sum_{k\ge 0} B(z)^k t^z = \frac{1}{1 - tB(z)}$$</div></p>
<p>也就是 <span class="markdown-them-math-inline">$A(z) = B(z)^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同样能得到 <span class="markdown-them-math-inline">$\text{SEQ}_{\ge k}(\mathcal B)$</span> 能引出 <span class="markdown-them-math-inline">$A(z) = \dfrac{B(z)^k}{1 - B(z)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于 <span class="markdown-them-math-inline">$\text{MSET}_k$</span> 有</p>
<p><div class="markdown-them-math-block">$$A(z, t) = \prod_{n\ge 0} (1 - tz^n)^{- B[n]}$$</div></p>
<p>这个得提取系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到</p>
<p><div class="markdown-them-math-block">$$A(z) = [t^k] \exp \left( \sum_{i\ge 1} \frac{t^iB(z^i)}{i} \right) = \sum_{i\ge 0} \frac{1}{i!} [t^k]\left( \sum_{j\ge 1} \frac{t^j B(z^j)}{j} \right)^i $$</div></p>
<p>对于有限制的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>没有要求 <span class="markdown-them-math-inline">$\mathcal B_0 = \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>常用的有限制构造</summary>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\text{PSET}_k(\mathcal A) &amp;= [u^k]\exp\left( \sum_{i \ge 1}(-1)^{i + 1} \frac{u^i}{i}A(z^i) \right) \\
\text{MSET}_k(\mathcal A) &amp;= [u^k]\exp\left( \sum_{i \ge 1} \frac{u^i}{i}A(z^i) \right) \\
\text{CYC}_k(\mathcal A) &amp;= [u^k]\sum_{i\ge 1} \frac{\varphi(i)}{i} \log \frac{1}{1 - u^iA(z^i)}
\end{aligned}$$</div></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\text{PSET}_2(\mathcal A) &amp;= \frac{A(z)^2}{2} - \frac{A(z^2)}{2} \\
\text{MSET}_2(\mathcal A) &amp;= \frac{A(z)^2}{2} + \frac{A(z^2)}{2} \\
\text{CYC}_2(\mathcal A) &amp;= \frac{A(z)^2}{2} + \frac{A(z^2)}{2}
\end{aligned}$$</div></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\text{PSET}_3(\mathcal A) &amp;= \frac{A(z)^3}{6} - \frac{A(z)A(z^2)}{2} + \frac{A(z^3)}{3}  \\
\text{MSET}_3(\mathcal A) &amp;= \frac{A(z)^3}{6} + \frac{A(z)A(z^2)}{2} + \frac{A(z^3)}{3}  \\
\text{CYC}_3(\mathcal A) &amp;= \frac{A(z)^3}{3} + \frac{2A(z^3)}{3}
\end{aligned}$$</div></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\text{PSET}_4(\mathcal A) &amp;= \frac{A(z)^4}{24} - \frac{A(z)^2A(z^2)}{4} + \frac{A(z)A(z^3)}{3} + \frac{A(z^2)^2}{8} - \frac{A(z^4)}{4}  \\
\text{MSET}_4(\mathcal A) &amp;= \frac{A(z)^4}{24} + \frac{A(z)^2A(z^2)}{4} + \frac{A(z)A(z^3)}{3} + \frac{A(z^2)^2}{8} + \frac{A(z^4)}{4}  \\
\text{CYC}_4(\mathcal A) &amp;= \frac{A(z)^4}{4} + \frac{A(z^2)^2}{4} + \frac{A(z^4)}{2}
\end{aligned}$$</div></p>
</details>
<p>我们或许也可以通过 Pólya 定理导出结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>讲解可以看 <a target="_blank" rel="noopener" href="https://handwiki.org/wiki/P%C3%B3lya_enumeration_theorem">HandWiki</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://encyclopediaofmath.org/wiki/P%C3%B3lya_theorem">Ency</a> 或 <a target="_blank" rel="noopener" href="https://xyix.github.io/posts/?page=0&amp;postname=combinatorics">x义x</a>.</p>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://loj.ac/p/6538">烷基计数</a></p>
<blockquote>
<p>计数 <span class="markdown-them-math-inline">$n$</span> 个节点的根节点度数不超过 <span class="markdown-them-math-inline">$3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其余节点度数不超过 <span class="markdown-them-math-inline">$4$</span> 的无序有根树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>考虑我们把更小的满足条件的树的根连接到新根节点上时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会新建一条边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这也不会让原来的根的度数超过 <span class="markdown-them-math-inline">$4$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此假设满足条件的树的组合类为 <span class="markdown-them-math-inline">$\mathcal T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以写出</p>
<p><div class="markdown-them-math-block">$$\mathcal T = \mathcal Z \times \text{MSET}_{\le 3} (\mathcal T)$$</div></p>
<p>或者直接按能接上一棵空树来计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$\hat{\mathcal T} = \mathcal T + \mathcal E$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以写出</p>
<p><div class="markdown-them-math-block">$$\hat{\mathcal T} = \mathcal E + \mathcal Z \times \text{MSET}_3(\hat{\mathcal T})$$</div></p>
<p><span class="markdown-them-math-inline">$\textbf{例 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有序树的进一步探讨</p>
<p>承接 <span class="markdown-them-math-inline">$2.1$</span> 例 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们限制每个节点子树的数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$\Omega\subseteq \mathbb N$</span> 为一个包含 <span class="markdown-them-math-inline">$0$</span> 的集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们定义组合类 <span class="markdown-them-math-inline">$\mathcal T^{\Omega}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的对象被称作 <span class="markdown-them-math-inline">$\Omega$</span> 树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一棵 <span class="markdown-them-math-inline">$\Omega$</span> 树需要满足任意节点的儿子数量 <span class="markdown-them-math-inline">$\omega \in \Omega$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在接下来的讨论中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常要用到 <span class="markdown-them-math-inline">$\Omega$</span> 的特征函数</p>
<p><div class="markdown-them-math-block">$$\phi(t) = \sum_{\omega \in \Omega} t^\omega$$</div></p>
<p>举几个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\Omega = \{0, 2\}$</span> 对应的组合对象是满二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中每个节点要么没有儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要么有两个儿子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它的特征函数是 <span class="markdown-them-math-inline">$\phi(t) = 1 + t^2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\Omega = \{0, 1, 2\}$</span> 对应的组合对象是一般的二叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特征函数是 <span class="markdown-them-math-inline">$\phi(t) = 1 + t + t^2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><span class="markdown-them-math-inline">$\Omega = \{0, 3\}$</span> 对应的组合对象是三叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特征函数是 <span class="markdown-them-math-inline">$\phi(t) = 1 + t^3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于一般的树有 <span class="markdown-them-math-inline">$\Omega = \mathbb N$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特征函数是 <span class="markdown-them-math-inline">$\phi(t) = (1 - t)^{-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们可以通过 <span class="markdown-them-math-inline">$\Omega$</span> 的特征函数 <span class="markdown-them-math-inline">$\phi$</span> 递归定义 <span class="markdown-them-math-inline">$\mathcal T^{\Omega}$</span> 的 <span class="markdown-them-math-inline">$\text{OGF}$</span> <span class="markdown-them-math-inline">$T^{\Omega}(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$T^{\Omega}(z) = z\times \phi\left(T^{\Omega}(z)\right)$$</div></p>
<p>这形式的证明需要从 <span class="markdown-them-math-inline">$\text{SEQ}$</span> 构造着手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个节点限制儿子的数量后子树的选择方案可以施 <span class="markdown-them-math-inline">$\text{SEQ}_{\in \Omega}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对组合类我们能写出 <span class="markdown-them-math-inline">$\mathcal T^{\Omega} = \mathcal Z\times \text{SEQ}_{\in \Omega} (\mathcal T^{\Omega})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>之前的讨论可以推广到这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种构造翻译成生成函数就是复合 <span class="markdown-them-math-inline">$\phi$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是 <span class="markdown-them-math-inline">$T^{\Omega}(z) = z\times \phi\left(T^{\Omega}(z)\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>上面的形式启发我们通过拉格朗日反演提取系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们知道 <span class="markdown-them-math-inline">$\dfrac{T^{\Omega}(z)}{\phi\left(T^{\Omega}(z)\right)} = z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就有 <span class="markdown-them-math-inline">$\left(T^{\Omega}(z)\right)^{\langle -1\rangle} = \dfrac{z}{\phi(z)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以得到</p>
<p><div class="markdown-them-math-block">$$\mathcal T^{\Omega}_n = [z^n] T^{\Omega}(z) = \frac{1}{n}[z^{n - 1}] \phi(z)^n$$</div></p>
<p>如上的思路在 <span class="markdown-them-math-inline">$\Omega$</span> 为多重集时自然成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\Omega = \{0, 1, 1, 3\}$</span> 给出了一种一叉-三叉树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这类树可以有两种一叉节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别染了不同的颜色<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>这集合的特征函数就是 <span class="markdown-them-math-inline">$\phi(z) = 1 + 2z + z^3$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>由上面的讨论不难看出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$\Omega$</span> 包含了 <span class="markdown-them-math-inline">$r$</span> 个不同的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则对 <span class="markdown-them-math-inline">$\Omega$</span> 树的计数可以用一个 <span class="markdown-them-math-inline">$r - 1$</span> 重的二项式系数求和表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们也可以用这种方法计数 <span class="markdown-them-math-inline">$k$</span> 阶 <span class="markdown-them-math-inline">$\Omega$</span> 树森林<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其组合类定义为 <span class="markdown-them-math-inline">$\mathcal F = \text{SEQ}_k(\mathcal T^{\Omega})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>关注生成函数能得到 <span class="markdown-them-math-inline">$F(z) = T^{\Omega}(z)^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
同样应用拉格朗日反演可以得到</p>
<p><div class="markdown-them-math-block">$$[z^n] F(z) = [z^n]T(z)^k = \frac{k}{n} [z^{n - k}] \phi(z)^n$$</div></p>
<p>当 <span class="markdown-them-math-inline">$\Omega = \mathbb N$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有 <span class="markdown-them-math-inline">$k$</span> 阶一般树森林的计数为</p>
<p><div class="markdown-them-math-block">$$[z^n] \left(\frac{1 - \sqrt{1 - 4z}}{2}\right)^k = \frac{k}{n}\binom{2n - k - 1}{n - 1}$$</div></p>
<p>系数对应的数列又被称为 <a target="_blank" rel="noopener" href="https://oeis.org/A009766">ballot numbers</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当 <span class="markdown-them-math-inline">$\Omega = \{0, 1, 2\}$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$\mathcal M$</span> 为对应的一般二叉树的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不难写出 <span class="markdown-them-math-inline">$\mathcal M = \mathcal Z\times \text{SEQ}_{\le 2}(\mathcal M)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就能得到</p>
<p><div class="markdown-them-math-block">$$M(z) = z\left(1 + M(z) + M^2(z)\right)\quad \Rightarrow \quad M(z) = \frac{1 - z - \sqrt{1 - 2z - 3z^2}}{2z}$$</div></p>
<p>可以用拉格朗日反演导出</p>
<p><div class="markdown-them-math-block">$$[z^n]M(z) = \frac{1}{n} \sum_{k &gt; 0} \binom{n}{k} \binom{n - k}{k - 1}$$</div></p>
<p>系数对应的数列<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>移位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>又被称为 <a target="_blank" rel="noopener" href="https://oeis.org/A001006">Motzkin numbers</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可能的例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7592">P7592 数树</a></p>
<p><span class="markdown-them-math-inline">$\textbf{例 3}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>被括号包含<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>bracketed<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>这个问题被论文 Vier combinatorische Probleme, E. Schröder 系统地阐述后广为人知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它也是这篇论文中的第二个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们需要计数的是 <span class="markdown-them-math-inline">$n$</span> 个相同的字母 <span class="markdown-them-math-inline">$x$</span> 有多少种被括号包含的合法方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>合法方案是递归地定义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$x$</span> 本身是合法方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>若 <span class="markdown-them-math-inline">$\sigma_1, \sigma_2, \dots, \sigma_k$</span> 分别是合法方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$k \ge  2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$(\sigma_1 \sigma_2 \cdots \sigma_k)$</span> 是合法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是并列后在最外层加一对括号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$(((xx)x(xxx))((xx)(xx)x))$</span> 是合法的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$((((x)(x))))$</span> 就不是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们令 <span class="markdown-them-math-inline">$\mathcal S$</span> 表示合法方案对应的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小函数表示一个方案中 <span class="markdown-them-math-inline">$x$</span> 的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上面的递归定义可以被形式化地表示为</p>
<p><div class="markdown-them-math-block">$$\mathcal S = \mathcal Z + \text{SEQ}_{\ge 2}(\mathcal S)$$</div></p>
<p>翻译得到</p>
<p><div class="markdown-them-math-block">$$S(z) = z + \frac{S(z)^2}{1 - S(z)}$$</div></p>
<p>考虑一个合法序列和一棵树的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个 <span class="markdown-them-math-inline">$x$</span> 代表的就是这棵树的叶子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而一对括号代表了树的内部节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要保证内部节点的度数 <span class="markdown-them-math-inline">$\ge 2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>叶子节点在这里对大小函数有贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>内部节点则没有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
注意这里树的形式和例 <span class="markdown-them-math-inline">$2$</span> 中描述的形式不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小函数的定义也不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法直接应用上面的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是拉格朗日反演仍然可以应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里有<br>
<div class="markdown-them-math-block">$$S^{\langle -1\rangle}(z) = \frac{x(1 - 2x)}{1-x}$$</div></p>
<p>提取 <span class="markdown-them-math-inline">$z^n$</span> 项系数可以得到</p>
<p><div class="markdown-them-math-block">$$\frac{1}{n} [z^{n -1}]\left(\frac{1-x}{1 -2x}\right)^{n} = \frac{(-1)^{n - 1}}{n} \sum_{k\ge 0} (-2)^k \binom{n}{k + 1}\binom{n + k - 1}{k}$$</div></p>
<p>这个其实微分有限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>化成组合数形式也只是为了得到新的组合意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>系数对应的数列是 <a target="_blank" rel="noopener" href="https://oeis.org/A001003">A1003</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="隐式构造">隐式构造</h2>
<p>在很多情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们会见到隐式构造的组合类 <span class="markdown-them-math-inline">$\mathcal X$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它作为一个映射的原像出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而像已经被定义了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们希望刻画这种组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将他显式地放在像的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这就促使我们在组合类运算中定义逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们举几个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$\mathcal A, \mathcal B$</span> 已知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal X$</span> 是新定义的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\mathcal A = \mathcal B + \mathcal X \quad \mathcal A = \mathcal B \times \mathcal X \quad \mathcal A = \text{SEQ}(\mathcal X) \quad \mathcal A = \text{MSET}(\mathcal X)$$</div></p>
<p>这里用生成函数的语言更容易定义逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分别地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有</p>
<p><div class="markdown-them-math-block">$$X(z) = A(z) - B(z) \quad X(z) = \frac{A(z)}{B(z)} \quad X(z) = 1 - \frac{1}{A(z)}\quad X(z) = \sum_{k\ge 1} \frac{\mu(k)}{k} \ln A(z^k)$$</div></p>
<p><span class="markdown-them-math-inline">$\text{MSET}$</span> 的逆的形式已经在 <span class="markdown-them-math-inline">$2.2$</span> 例 <span class="markdown-them-math-inline">$3$</span> 讨论了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>通过组合类间关系隐式构造的组合类被称为隐式结构<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>implicit structures<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>排列的连续段分解</p>
<p>一个排列 <span class="markdown-them-math-inline">$\sigma = \sigma_1 \sigma_2 \cdots \sigma_n$</span> 是可分解的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当其下标可以被分割为<strong>大于一个</strong>不交的区间 <span class="markdown-them-math-inline">$[l_i, r_i] = \{k \mid k\in \mathbb N \land l_i\le k \le r_i \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足</p>
<ol>
<li>这些区间的并集是 <span class="markdown-them-math-inline">$[1,n] = \{k \mid k\in \mathbb N \land 1\le k \le n \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li>对任何一个区间 <span class="markdown-them-math-inline">$[l,r]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\forall i \in [l, r], \exists j\in [l, r], \sigma_i = j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li>对任意两个区间 <span class="markdown-them-math-inline">$[l_i, r_i], [l_j, r_j]$</span> 满足 <span class="markdown-them-math-inline">$i &lt; j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$\forall x \in [l_i, r_i], \forall y \in [l_j, r_j], \sigma_x &lt; \sigma_y$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li>区间数量极大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\sigma = \{2,5,4,1,3,6,8,10,7,9\}$</span> 的分解就是 <span class="markdown-them-math-inline">$[1, 5], [6, 6], [7, 10]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用图像表示就是</p>
<p><img src="https://img2023.cnblogs.com/blog/2725805/202302/2725805-20230201091747962-1339397952.png" alt="image"></p>
<p>我们称无法执行上述操作的排列是不可分解的排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如 <span class="markdown-them-math-inline">$\{2,4,1,3\}, \{5,4,3,2,1\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在请构造不可分解的排列的组合类 <span class="markdown-them-math-inline">$\mathcal I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们取出排列 <span class="markdown-them-math-inline">$\sigma$</span> 的分解中的一段 <span class="markdown-them-math-inline">$[l,r]$</span> 来观察<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不难发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排列 <span class="markdown-them-math-inline">$\{\sigma_l - l + 1, \sigma_{l+1} - l + 1, \dots, \sigma_r - l + 1 \}$</span> 是一个新的 <span class="markdown-them-math-inline">$1\sim r - l + 1$</span> 的排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且这个排列是不可再分解的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们如果只关注排列的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则一个可分解的排列是一系列不可分解的排列的并列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设任意排列的组合类是 <span class="markdown-them-math-inline">$\mathcal P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们能得到</p>
<p><div class="markdown-them-math-block">$$\mathcal P = \text{SEQ}(\mathcal I)$$</div></p>
<p>这隐式定义了 <span class="markdown-them-math-inline">$\mathcal I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以写出</p>
<p><div class="markdown-them-math-block">$$I(z) = 1 - \frac{1}{P(z)} \qquad \text{where} \  P(z) = \sum_{n\ge 0}n ! z^n$$</div></p>
<p>系数对应的数列是 <a target="_blank" rel="noopener" href="https://oeis.org/A003319">A3319</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\textbf{例 2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>系数在有限域内的素多项式</p>
<p>我们固定一个质数 <span class="markdown-them-math-inline">$p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下面所有系数间的运算都在模 <span class="markdown-them-math-inline">$p$</span> 数域 <span class="markdown-them-math-inline">$\mathbb F_p$</span> 内运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记多项式环 <span class="markdown-them-math-inline">$\mathbb F_p[x]$</span> 是系数在 <span class="markdown-them-math-inline">$\mathbb F_p$</span> 内的多项式的全体组成的环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们在这里讨论的是首一多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即最高次项系数为 <span class="markdown-them-math-inline">$1$</span> 的多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$\mathbb F_p[x]$</span> 集合内的首一多项式组成了组合类 <span class="markdown-them-math-inline">$\mathcal P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小函数定义为多项式最高次项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$\mathcal A = \mathbb F_p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于一个多项式可以由它的系数唯一确定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以将它视作由 <span class="markdown-them-math-inline">$\mathcal A$</span> 内对象组成的序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有</p>
<p><div class="markdown-them-math-block">$$\mathcal P = \text{SEQ}(\mathcal A) \quad \Rightarrow \quad P(z) = \frac{1}{1 - pz}$$</div></p>
<p>这也能得到有 <span class="markdown-them-math-inline">$p^n$</span> 个最高次项为 <span class="markdown-them-math-inline">$x^n$</span> 的首一多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>众所周知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多项式域 <span class="markdown-them-math-inline">$\mathbb F_p[x]$</span> 上可以作欧几里得法求最大公因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此多项式域是 <span class="markdown-them-math-inline">$\text{UFD}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们称没有除常数外的因子的多项式是素多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是不可分解的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$\mathbb F_3[x]$</span> 上有</p>
<p><div class="markdown-them-math-block">$$x^{10} + x^8 + 1 = (x + 1)^2(x + 2)^2 (x^6 + 2x^2 + 1)$$</div></p>
<p>我们令 <span class="markdown-them-math-inline">$\mathcal I$</span> 为素多项式对应的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>唯一分解性质说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal P$</span> 在组合意义上和 <span class="markdown-them-math-inline">$\mathcal I$</span> 的 <span class="markdown-them-math-inline">$\text{Multiset}$</span> 构造同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是</p>
<p><div class="markdown-them-math-block">$$\mathcal P\cong \text{MSET}(\mathcal I)$$</div></p>
<p>这样我们就能写出</p>
<p><div class="markdown-them-math-block">$$P(z) = \exp\left(  \sum_{j\ge 1} \frac{I(z^j)}{j} \right)$$</div></p>
<p>我们也自然能通过上面的方法以及提取系数得到</p>
<p><div class="markdown-them-math-block">$$I(z) = \sum_{k\ge 1} \frac{\mu(k)}{k} \ln \frac{1}{1 - pz^k}\quad \mathcal I_n = \frac{1}{n} \sum_{d | n} \mu(d) {p}^{n / d}$$</div></p>
<p>特别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal I_n = O(p^n / n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个结论已经被高斯知晓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$n$</span> 度的多项式中任选一个多项式是素多项式的概率为 <span class="markdown-them-math-inline">$1/n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="有标号体系">有标号体系</h1>
<h2 id="概述">概述</h2>
<p>有标号体系是无标号体系的自然拓展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大部分组合对象的性质都可以自然地引入有标号体系中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有标号体系和无标号体系最大的区别在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有标号体系所关注的对象都有着两两不同的标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>彼此可以区分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不失一般性地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将标号集合视作正整数集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个排列可以被视作一系列两两不同正整数依次排开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而循环分解将这排列视作循环有向图的组合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>图的每个顶点都有着正整数标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有标号体系内的操作基于一类特殊的乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有标号乘<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>labelled product<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它是对无标号体系中笛卡尔积的自然模拟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
同样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们也需要得到对无标号体系中 <span class="markdown-them-math-inline">$\text{OGF}$</span> 的有标号模拟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/poly-and-gf.html#_-1">指数生成函数</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简称 <span class="markdown-them-math-inline">$\text{EGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在下面的叙述中我们可以看到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{EGF}$</span> 可以很好地描述计数序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
新的构造使得我们能关注更多的结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别是在有顺序的性质上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="记号与定义-1">记号与定义</h2>
<p>我们所处理的对象和无标号体系一样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是有限的组合类与组合对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不同的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们现在处理的组合对象是有标签的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个组合对象都[有一种独特的颜色/被分配到一个正整数标号]<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以保证组合对象是两两不同的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一个大小为 <span class="markdown-them-math-inline">$n$</span> 的<strong>弱标号</strong>对象是一种有 <span class="markdown-them-math-inline">$n$</span> 个部分的离散结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其 <span class="markdown-them-math-inline">$n$</span> 个部分分别有一个标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些标号组成了一个大小为 <span class="markdown-them-math-inline">$n$</span> 的整数集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们称满足这条件的对象是弱标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>等价地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以说每个部分都有标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种叙述隐含了标号是 <span class="markdown-them-math-inline">$\in \mathbb Z$</span> 的彼此不同的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个大小为 <span class="markdown-them-math-inline">$n$</span> 的<strong>有标号</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>又称强标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般在需要区分弱标号对象的语境下使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对象需要是弱标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且其标号组成的集合是整数区间 <span class="markdown-them-math-inline">$[1, n] = \{x\mid x\in \mathbb N, 1\le x\le n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个例子是一张有 <span class="markdown-them-math-inline">$n$</span> 个节点的图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的一个部分是一个带标号节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
一个有标号类是一个由有标号的组合对象组成的组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里把 <span class="markdown-them-math-inline">$1.$</span> 中介绍过的无标号的组合类称作无标号类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以示区分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对有标号类的记号仍然沿用美术花体<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>\mathcal</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>大写字母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中的一个有标号对象常记作对应的小写字母/希腊字母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对应的生成函数用对应的一般字体大写字母记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有标号类也是一个组合类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>计数序列和同构等定义与 <span class="markdown-them-math-inline">$1.$</span> 中介绍的无标号类相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一个有标号类 <span class="markdown-them-math-inline">$\mathcal A$</span> 的 <span class="markdown-them-math-inline">$\text{EGF}$</span> 可以用它的计数序列 <span class="markdown-them-math-inline">$A[n]$</span> 或其中元素表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写作</p>
<p><div class="markdown-them-math-block">$$A(z) = \sum_{i\ge 0} A[i] \frac{z^i}{i!} = \sum_{\alpha \in \mathcal A} \frac{z^{\lvert \alpha \rvert}}{\lvert \alpha \rvert!} $$</div></p>
<p>这里的 <span class="markdown-them-math-inline">$z$</span> 是用于标记组合对象大小的占位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里作一下关于 <span class="markdown-them-math-inline">$\text{EGF}$</span> 的提取系数的声明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>提取系数需要满足 <span class="markdown-them-math-inline">$A[n] = n!\times [z^n]A(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是 <span class="markdown-them-math-inline">$[z^n]A(z) = A[n]/n!$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="基础有标号类与操作">基础有标号类与操作</h2>
<p>在无标号体系中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们已经见到了中性类和原子类发挥的作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨在有标号体系中也定义这样的结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们记 <span class="markdown-them-math-inline">$\epsilon$</span> 为中性对象<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>neutral object<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对应的组合类记作 <span class="markdown-them-math-inline">$\mathcal E = \{\epsilon \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称作中性类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>neutral class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
恒有 <span class="markdown-them-math-inline">$\lvert \epsilon \rvert = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有中性类的 <span class="markdown-them-math-inline">$\text{EGF}$</span> <span class="markdown-them-math-inline">$E(z) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们记 <span class="markdown-them-math-inline">$①$</span> 为原子对象<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>atom object<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对应的组合类记作 <span class="markdown-them-math-inline">$\mathcal Z = \{① \}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称作原子类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>atom class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们令原子对象中唯一的元素标号恒为 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这使得原子对象是强标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
恒有 <span class="markdown-them-math-inline">$\lvert① \rvert = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有原子类的 <span class="markdown-them-math-inline">$\text{EGF}$</span> <span class="markdown-them-math-inline">$Z(z) = z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有标号类的集合并可以类似无标号类的集合并一样定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里也记作 <span class="markdown-them-math-inline">$+$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal A + \mathcal B$</span> 翻译到生成函数上就是 <span class="markdown-them-math-inline">$A(z) + B(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>而有标号类的乘法不好得到良定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是由于笛卡尔积的结构可能导出非良标号对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是两个有标号对象可能存在标号重叠的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们不采用笛卡尔积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是定义新的运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有标号乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这运算可以自然地翻译为 <span class="markdown-them-math-inline">$\text{EGF}$</span> 的乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记 <span class="markdown-them-math-inline">$\mathcal A$</span> 与 <span class="markdown-them-math-inline">$\mathcal B$</span> 的有标号乘法为 <span class="markdown-them-math-inline">$\mathcal A \times \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它翻译到生成函数上是 <span class="markdown-them-math-inline">$A(z)\times B(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意这里没有定义 <span class="markdown-them-math-inline">$\mathcal A,\mathcal B$</span> 的笛卡尔积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们也不使用 <span class="markdown-them-math-inline">$\star$</span> 代替 <span class="markdown-them-math-inline">$\times$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先介绍二项式卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是 <span class="markdown-them-math-inline">$\text{EGF}$</span> 在做乘法运算时系数的映射结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$F(z), G(z), H(z)$</span> 分别是序列 <span class="markdown-them-math-inline">$f, g, h$</span> 的 <span class="markdown-them-math-inline">$\text{EGF}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$F(z) = G(z)\times H(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>能发现它们的系数满足</p>
<p><div class="markdown-them-math-block">$$\frac{f[n]}{n!} = \sum_{k = 0}^n \frac{g[k]}{k!} \times \frac{h[n - k]}{(n - k)!} \quad \Rightarrow \quad f[n] = \sum_{k = 0}^{n}\binom{n}{k} g[k] \times h[n - k]$$</div></p>
<p>同样的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们有 <span class="markdown-them-math-inline">$F(z) = G_1(z)\times G_2(z)\times\cdots\times G_r(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则</p>
<p><div class="markdown-them-math-block">$$f[n] = \sum_{n_1 + n_2 + \cdots n_r = n} \binom{n}{n_1, n_2, \dots, n_r} g_1[n_1] \times g_2[n_2]\times\cdots\times g_r[n_r]$$</div></p>
<p>这里的系数是多项式系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有</p>
<p><div class="markdown-them-math-block">$$\binom{n}{n_1, n_2, \dots, n_r} = \frac{n!}{n_1!\times n_2!\times \cdots \times n_r!}$$</div></p>
<p>这种结构对我们下面的讨论很有帮助<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是 <span class="markdown-them-math-inline">$\text{EGF}$</span> 应用的核心所在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们接下来要讨论的是重标号操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于我们需要让两个强标号对象合并后仍然是强标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们需要进行重标号操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种操作要求新的标号的大小关系中保留原标号之间的大小关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面列出的两种重标号方式是重要的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>减缩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
对于一个大小为 <span class="markdown-them-math-inline">$n$</span> 的弱标号结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减缩操作将每个点的标号映射到整数区间 <span class="markdown-them-math-inline">$[1, n]$</span> 内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保留了原标号的大小关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相当于作了离散化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们记对结构 <span class="markdown-them-math-inline">$\alpha$</span> 做减缩操作得到 <span class="markdown-them-math-inline">$\rho(\alpha)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>序列 <span class="markdown-them-math-inline">$\langle 7, 3, 9, 2 \rangle$</span> 减缩得到 <span class="markdown-them-math-inline">$\langle 3, 2, 4, 1 \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>增扩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
定义该操作需要一个增扩函数 <span class="markdown-them-math-inline">$e : [1, n]\to \mathbb Z$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>满足 <span class="markdown-them-math-inline">$\forall i\in [1, n], e(i) &gt; i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于一个强标号对象 <span class="markdown-them-math-inline">$\alpha$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义它增扩后得到一个弱标号对象 <span class="markdown-them-math-inline">$\hat\alpha$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\alpha$</span> 中标号为 <span class="markdown-them-math-inline">$k$</span> 的部分在 <span class="markdown-them-math-inline">$\hat\alpha$</span> 中标号为 <span class="markdown-them-math-inline">$e(k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们记对结构 <span class="markdown-them-math-inline">$\alpha$</span> 做增扩操作得到 <span class="markdown-them-math-inline">$e(\alpha)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>序列 <span class="markdown-them-math-inline">$\langle 3, 2, 4, 1 \rangle$</span> 增扩可以得到 <span class="markdown-them-math-inline">$\langle 33, 22, 44, 11 \rangle$</span> 或 <span class="markdown-them-math-inline">$\langle 7, 3, 9, 2 \rangle$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ol>
<p>我们可以通过这些操作设计出一种适于有标号类的乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其最初由 <a target="_blank" rel="noopener" href="https://www.semanticscholar.org/paper/La-s%C3%A9rie-g%C3%A9n%C3%A9ratrice-exponentielle-dans-les-Foata/6315424b2aab52732f4e3ffa4ec651679c7d0e34">D. Foata</a> 提出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取名为 partitional product<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有标号乘法的思路就是对合并后的部分进行重标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以避免出现同一个标号出现多次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们取两个有标号对象 <span class="markdown-them-math-inline">$\beta \in \mathcal B$</span> 和 <span class="markdown-them-math-inline">$\gamma \in \mathcal C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义这两个对象的有标号乘法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>简称乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>记作 <span class="markdown-them-math-inline">$\beta \times \gamma$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义为一个集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其包含所有由 <span class="markdown-them-math-inline">$(\beta, \gamma)$</span> 生成的强标号的有序对 <span class="markdown-them-math-inline">$(\beta', \gamma ')$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义</p>
<p><div class="markdown-them-math-block">$$\beta\times \gamma = \{ (\beta', \gamma) \mid (\beta', \gamma ')强标号, \rho(\beta') = \beta, \rho(\gamma') = \gamma \}$$</div></p>
<p>这个定义同样可以通过增扩导出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不再赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>注意到有标号乘积导出的构造中每个对象都是强标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$\beta, \gamma$</span> 都是强标号的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大小分别为 <span class="markdown-them-math-inline">$n_1, n_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则分配标号的方案总共有 <span class="markdown-them-math-inline">$\dbinom{n_1 + n_2}{n_1}$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是说</p>
<p><div class="markdown-them-math-block">$$\lvert\beta\times \gamma\rvert = \dbinom{n_1 + n_2}{n_1}$$</div></p>
<p>随后我们就能对有标号类自然地定义有标号乘法了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>设 <span class="markdown-them-math-inline">$\mathcal B, \mathcal C$</span> 是两个有标号类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$\mathcal B$</span> 和 <span class="markdown-them-math-inline">$\mathcal C$</span> 的有标号乘法记作 <span class="markdown-them-math-inline">$\mathcal B \times \mathcal C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义为</p>
<p><div class="markdown-them-math-block">$$\mathcal B \times \mathcal C = \bigcup_{\beta \in \mathcal B, \gamma \in \mathcal C} \beta\times \gamma$$</div></p>
<p>随后我们可以自然地描述计数序列的关系了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设 <span class="markdown-them-math-inline">$\mathcal A = \mathcal B \times \mathcal C$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则我们能知道</p>
<p><div class="markdown-them-math-block">$$\mathcal A_n = \bigcup_{|\beta| + |\gamma| = n} \beta\times \gamma\quad\Rightarrow\quad A[n] = \sum_{i + j = n} \binom{n}{i} B[i]\times C[j]$$</div></p>
<p>可以发现这转移和 <span class="markdown-them-math-inline">$\text{EGF}$</span> 的乘法同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此我们构造出了一种有意义的有标号乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得 <span class="markdown-them-math-inline">$\text{EGF}$</span> 可以用来描述组合类的计数序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>通过这个构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以构造有标号集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>有标号序列和有标号循环了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方法和无标号的构造法类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这过程中我们也会注意可容许性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="经典的有标号构造">经典的有标号构造</h1>
<h2 id="有标号-$\text{sequence}$ 构造">有标号 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造</h2>
<p>有标号 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造生成了所有可能的有标号序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一个有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span> 的 <span class="markdown-them-math-inline">$k$</span> 次<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>有标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>幂被定义为 <span class="markdown-them-math-inline">$\mathcal A = \mathcal B\times \mathcal B\times \cdots \times \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里有 <span class="markdown-them-math-inline">$k$</span> 个 <span class="markdown-them-math-inline">$\mathcal B$</span> 作乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>翻译为生成函数为 <span class="markdown-them-math-inline">$A(z) = B(z)^k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$\mathcal B$</span> 的 <span class="markdown-them-math-inline">$k$</span> 次<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>有标号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>幂记作 <span class="markdown-them-math-inline">$\text{SEQ}_k(\mathcal B)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义</p>
<p><div class="markdown-them-math-block">$$\text{SEQ}(\mathcal A) = \mathcal E + \mathcal A + \mathcal A\times \mathcal A + \mathcal A \times \mathcal A\times \mathcal A + \cdots = \bigcup_{k\ge 0} \text{SEQ}_k(\mathcal A)$$</div></p>
<p>记 <span class="markdown-them-math-inline">$\mathcal B = \text{SEQ}(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$B(z) = 1 + A(z) + A(z)^2 + A(z)^3 + \cdots = \frac{1}{1 - A(z)}$$</div></p>
<p>这里仍然需要 <span class="markdown-them-math-inline">$\mathcal A_0 \neq \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="有标号-$\text{set}$ 构造">有标号 <span class="markdown-them-math-inline">$\text{Set}$</span> 构造</h2>
<p>有标号 <span class="markdown-them-math-inline">$\text{Set}$</span> 构造生成了所有可能的有标号序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不区分组成对象的元素的顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>由有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span> 中对象作为元素的大小为 <span class="markdown-them-math-inline">$k$</span> 的集合的全体就是有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span> 的 <span class="markdown-them-math-inline">$\text{Set}_k$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它是无标号类中 <span class="markdown-them-math-inline">$\text{Multiset}, \text{Powerset}$</span> 构造的模拟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义为 <span class="markdown-them-math-inline">$\text{SET}_k(\mathcal B) = \text{SEQ}_k(\mathcal B) / \textbf R$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$(a_1, a_2, \dots, a_n)\textbf{R}(b_1, b_2, \dots, b_n)$</span> 当且仅当存在一个置换 <span class="markdown-them-math-inline">$\sigma$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于任意 <span class="markdown-them-math-inline">$j$</span> 满足 <span class="markdown-them-math-inline">$b_j = a_{\sigma(j)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
由有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span> 中对象作为元素的集合的全体就是有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span> 的 <span class="markdown-them-math-inline">$\text{Set}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们定义</p>
<p><div class="markdown-them-math-block">$$\text{SET}(\mathcal A) = \bigcup_{k\ge 0} \text{SET}_k(\mathcal A)$$</div></p>
<p>对于一个有标号类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有标号 <span class="markdown-them-math-inline">$\text{Set}_k$</span> 构造中的一个元素对应着有标号 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造中的 <span class="markdown-them-math-inline">$k!$</span> 个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以通过计数置换得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此可以将这构造翻译为生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>记 <span class="markdown-them-math-inline">$\mathcal B = \text{SET}_k(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Set}_k$</span> 构造翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$B(z) = \frac{1}{k!}A(z)^k$$</div></p>
<p>记 <span class="markdown-them-math-inline">$\mathcal B = \text{SET}(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Set}$</span> 构造翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$B(z) = \sum_{k\ge 0} \frac{1}{k!}A(z)^k = \exp A(z)$$</div></p>
<p>这里仍然需要 <span class="markdown-them-math-inline">$\mathcal A_0 \neq \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>注意到无标号 <span class="markdown-them-math-inline">$\text{Powerset}$</span> 构造和无标号 <span class="markdown-them-math-inline">$\text{Multiset}$</span> 构造在带标号后同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Powerset}$</span> 构造可以并入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>统称为有标号 <span class="markdown-them-math-inline">$\text{Set}$</span> 构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="有标号-$\text{cycle}$ 构造">有标号 <span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造生成了所有可能的有标号序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不区分仅轮换不同的序列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有标号 <span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造是无标号类中 <span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造的模拟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义为 <span class="markdown-them-math-inline">$\text{CYC}_k(\mathcal B) = \text{SEQ}_k(\mathcal B) / \textbf S$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$(a_1, a_2, \dots a_n) \textbf S(b_1, b_2, \dots, b_n)$</span> 当且仅当存在循环移位 <span class="markdown-them-math-inline">$\tau$</span> 使得对于任意 <span class="markdown-them-math-inline">$j$</span> 有 <span class="markdown-them-math-inline">$b_j = a_{\tau(j)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
同上地定义 <span class="markdown-them-math-inline">$\text{CYC}(\mathcal B) = \sum_{k\ge 0}\text{CYC}_k(\mathcal B)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{CYC}_k(\mathcal B)$</span> 中任意一个对象在 <span class="markdown-them-math-inline">$\text{SEQ}_k(\mathcal B)$</span> 中出现了恰好 <span class="markdown-them-math-inline">$k$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为每个对象都可以旋转 <span class="markdown-them-math-inline">$k$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此可以将这构造翻译为生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>记 <span class="markdown-them-math-inline">$\mathcal B = \text{CYC}_k(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Cycle}_k$</span> 构造翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$B(z) = \frac{1}{k}A(z)^k$$</div></p>
<p>记 <span class="markdown-them-math-inline">$\mathcal B = \text{CYC}(\mathcal A)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Cycle}$</span> 构造翻译为生成函数即为</p>
<p><div class="markdown-them-math-block">$$B(z) = \sum_{k\ge 0} \frac{1}{k}A(z)^k = \log \frac{1}{1 - A(z)}$$</div></p>
<p>这里仍然需要 <span class="markdown-them-math-inline">$\mathcal A_0 \neq \varnothing$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="有标号-$\text{pointing}$ 构造">有标号 <span class="markdown-them-math-inline">$\text{Pointing}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Pointing}$</span> 构造生成了所有可能的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>有根<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对于一个有标号类 <span class="markdown-them-math-inline">$\mathcal A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Pointing}$</span> 构造生成了一个有标号类 <span class="markdown-them-math-inline">$\mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得对于任意 <span class="markdown-them-math-inline">$\mathcal A_n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们都用 <span class="markdown-them-math-inline">$n$</span> 个彼此不同的中性对象分别单独标明 <span class="markdown-them-math-inline">$\forall \alpha \in \mathcal A_n$</span> 中一个单位大小的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即对于 <span class="markdown-them-math-inline">$\alpha$</span> 对应的 <span class="markdown-them-math-inline">$\{\beta\} \subseteq \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$\{\beta\} = \{\alpha \}\times \{\epsilon_1, \epsilon_2, \dots, \epsilon_n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现 <span class="markdown-them-math-inline">$\forall \alpha \in \mathcal A_n$</span> 都生成了 <span class="markdown-them-math-inline">$n$</span> 个不同的 <span class="markdown-them-math-inline">$\beta \in \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$\mathcal A$</span> 是有标号无根树类时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal B$</span> 就是有标号有根树类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$\text{PNT}(\mathcal A)$</span> 又记作 <span class="markdown-them-math-inline">$\Theta \mathcal A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>容易翻译为生成函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\mathcal A = \text{PNT}(\mathcal B)$</span> 则</p>
<p><div class="markdown-them-math-block">$$A(z) = \sum_{k\ge 0}k B[k]\frac{z^k}{k!} = z \sum_{k\ge 0}B[k + 1]\frac{z^k}{k!} = z B'(z)$$</div></p>
<p>这就是 <span class="markdown-them-math-inline">$A = \vartheta B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="有标号-$\text{substitution}$ 构造">有标号 <span class="markdown-them-math-inline">$\text{Substitution}$</span> 构造</h2>
<p><span class="markdown-them-math-inline">$\text{Substitution}$</span> 构造生成了所有可能的替换生成结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\text{Substitution}$</span> 构造是二元运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对有序二元组 <span class="markdown-them-math-inline">$(\mathcal A, \mathcal B)$</span> 的 <span class="markdown-them-math-inline">$\text{Substitution}$</span> 构造常记作 <span class="markdown-them-math-inline">$\mathcal A \circ \mathcal B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{Substitution}$</span> 构造将前一个有标号类中的元素的每个单位元替换为后一个组合类中的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式化地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义 <span class="markdown-them-math-inline">$\mathcal S \boxtimes \mathcal T = \{(s, t) \mid s \in \mathcal S, t \in \mathcal T , |(s, t)| = |t|\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有</p>
<p><div class="markdown-them-math-block">$$\mathcal A \circ \mathcal B = \sum_{k\ge 0} \mathcal A_k \boxtimes  \text{SET}_k(\mathcal B)$$</div></p>
<p>这翻译成生成函数就是复合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$A\circ B(x) = A(B(x))$$</div></p>
<p>我们也可以通过这构造来导出其他一些构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
举例来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设排列的有标号类是 <span class="markdown-them-math-inline">$\mathcal P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任意有标号类 <span class="markdown-them-math-inline">$\mathcal A$</span> 的 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造就是 <span class="markdown-them-math-inline">$\mathcal P\circ \mathcal A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$P(x) = \dfrac{1}{1 - x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以得到 <span class="markdown-them-math-inline">$\text{Sequence}$</span> 构造的经典表述 <span class="markdown-them-math-inline">$\dfrac{1}{1 - A(x)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在多项式复合的复杂度被<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/7joh5isi">优化至 <span class="markdown-them-math-inline">$O(n\log^2 n)$</span> 后</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该构造的适用性逐渐提升<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="d-finite-与 ode 自动机">d-finite 与 ODE 自动机</h1>
<h2 id="[定义](https://wwwmath.ucla.edu/~pak/papers/garrabrant-thesis.pdf)"><a target="_blank" rel="noopener" href="https://www.math.ucla.edu/~pak/papers/Garrabrant-thesis.pdf">定义</a></h2>
<p>对函数 <span class="markdown-them-math-inline">$y(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方程</p>
<p><div class="markdown-them-math-block">$$\sum_{i = 0}^n a_i(x) y^{(i)}(x) = C(x)$$</div></p>
<p>为其的一个 <span class="markdown-them-math-inline">$n$</span> 阶线性微分方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$C(x) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则其为一个齐次的线性微分方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并称满足这一方程的函数是微分有限<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\forall i, \text{deg }a_i(x) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则其是常系数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>反之则是变系数的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若对应函数是单变量的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就称对应的线性微分方程为常微分方程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>ordinary differential equation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对数列 <span class="markdown-them-math-inline">$\{a_n\}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方程</p>
<p><div class="markdown-them-math-block">$$\sum_{i = 0}^d p_i(n) a_{n - i} = 0$$</div></p>
<p>为其的一个 <span class="markdown-them-math-inline">$d$</span> 阶整式递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$\forall p_i(n)$</span> 为多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并称满足这一方程的函数是可多项式递推<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>P-recursive<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可以证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>
<p>令数列 <span class="markdown-them-math-inline">$\{a_n\}$</span> 的生成函数为 <span class="markdown-them-math-inline">$A(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 <span class="markdown-them-math-inline">$A(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当 <span class="markdown-them-math-inline">$\{a_n\}$</span> P-recursive<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>若 <span class="markdown-them-math-inline">$f(x), g(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则对任意常数 <span class="markdown-them-math-inline">$c_1, c_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$c_1 f(x) + c_2 g(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>若 <span class="markdown-them-math-inline">$f(x), g(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$f(x)g(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>若 <span class="markdown-them-math-inline">$f(x)$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g(x)$</span> 代数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$f(g(x))$</span> d-finite<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g(x)$</span> 代数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当存在不可约方程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不可被分解为两个次数较低的多项式之乘积的多项式与 <span class="markdown-them-math-inline">$0$</span> 形成的等式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\sum_{i = 0}^n a_i(x) g^i(x) = 0$$</div><br>
恒成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ol>
<h2 id="基础函数的构造">基础函数的构造</h2>
<ol>
<li>
<p><span class="markdown-them-math-inline">$f(x) = x^{\alpha}$</span><br>
考察 <span class="markdown-them-math-inline">$x f'(x) = x\times \alpha x^{\alpha - 1} = \alpha x^{\alpha} = \alpha f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有<br>
<div class="markdown-them-math-block">$$\alpha f - x f' = 0$$</div></p>
</li>
<li>
<p><span class="markdown-them-math-inline">$f(x) = e^x$</span><br>
考察 <span class="markdown-them-math-inline">$f'(x) = e^x = f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此有<br>
<div class="markdown-them-math-block">$$f - f' = 0$$</div></p>
</li>
<li>
<p><span class="markdown-them-math-inline">$f(x) = {}_pF_q(a_1,\dots, a_p; b_1, \dots, b_q; x)$</span><br>
令 <span class="markdown-them-math-inline">$\vartheta = xD$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有<br>
<div class="markdown-them-math-block">$$(\vartheta + a_1)\cdots (\vartheta + a_p) f = D (\vartheta + b_1 - 1)\cdots (\vartheta + b_q - 1) f$$</div></p>
</li>
<li>
<p><span class="markdown-them-math-inline">$f(x) = c\times g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$c$</span> 为与 <span class="markdown-them-math-inline">$x$</span> 无关的常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$f(x)$</span> 满足的微分方程和 <span class="markdown-them-math-inline">$g(x)$</span> 相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
写这个的原因是老是忘记常数咋处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>记住<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>微分方程不管常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常数无论如何都能消掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>递推时它们的信息由初值给出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ol>
<h2 id="如何实现&lt;span-class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;？&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;">如何实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></h2>
<p>一般而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们想要求得 ODE 的函数都是由上方基础函数加减乘除复合得来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们只需要让机器帮我们做两个 ODE 相加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>相乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>ODE 和代数函数复合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就基本上可以解决我们面对的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>受到我没看过的论文证明的启发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们应当维护对应 d-finite 函数 <span class="markdown-them-math-inline">$f$</span> 的各阶导数 <span class="markdown-them-math-inline">$f, f', f'', \dots$</span> 组成的线性空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面令系数都在模 <span class="markdown-them-math-inline">$p$</span> 意义下进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即属于域 <span class="markdown-them-math-inline">$F_p$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>令我们要处理的两个 d-finite 函数为 <span class="markdown-them-math-inline">$f(x), g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并令</p>
<p><div class="markdown-them-math-block">$$f^{(n)}(x) = \sum_{i = 0}^{n - 1} p_i(x) f^{(i)}(x), \qquad g^{(m)}(x) = \sum_{i = 0}^{m - 1} q_i(x) g^{(i)}(x)$$</div></p>
<p>其中 <span class="markdown-them-math-inline">$\forall p_i(x), q_i(x) \in F_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即系数均属于 <span class="markdown-them-math-inline">$F_p$</span> 的有理分式集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>此外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不妨令 <span class="markdown-them-math-inline">$n\le m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="$f(x)-+ g(x)$"><span class="markdown-them-math-inline">$f(x) + g(x)$</span></h3>
<p>考察 <span class="markdown-them-math-inline">$(f + g)^{(k)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们需要的就是用 <span class="markdown-them-math-inline">$f, \dots, f^{(n-1)}, g, \dots, g^{(m-1)}$</span> 表出每个 <span class="markdown-them-math-inline">$(f + g)^{(k)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当 <span class="markdown-them-math-inline">$k &lt; n$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>知道 <span class="markdown-them-math-inline">$(f + g)^{(k)} = f^{(k)} + g^{(k)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
当 <span class="markdown-them-math-inline">$k = n$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$(f + g)^{(n)} = f^{(n)} + g^{(n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 <span class="markdown-them-math-inline">$f^{(n)}$</span> 可使用微分方程降次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从而当 <span class="markdown-them-math-inline">$k \ge n$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若<br>
<div class="markdown-them-math-block">$$(f + g)^{(k)} = \sum_{i = 0}^{n - 1} a_{k, i}(x) f^{(i)} + \sum_{i = 0}^{n - 1}(x) b_{k, i} g^{(i)}$$</div><br>
则</p>
<p><div class="markdown-them-math-block">$$\begin{aligned} 
(f + g)^{(k + 1)} &amp;  = \left(\sum_{i = 0}^{n - 1} a_{k, i}(x) f^{(i)} + \sum_{i = 0}^{n - 1}(x) b_{k, i} g^{(i)}\right)'
\\ &amp; = \sum_{i = 0}^{n - 1}  \left(a_{k, i}'(x) f^{(i)} + a_{k, i}(x) f^{(i + 1)}\right) + \sum_{i = 0}^{n - 1}(x) \left(b_{k, i}'(x) g^{(i)} + b_{k,i}(x) g^{(i+1)}\right)
\end{aligned}$$</div></p>
<p>随后只需将 <span class="markdown-them-math-inline">$f^{(n)}$</span> 用微分方程降次即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样由归纳法可以知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们总能将每个 <span class="markdown-them-math-inline">$(f + g)^{(k)}$</span> 用 <span class="markdown-them-math-inline">$f, \dots, f^{(n-1)}, g, \dots, g^{(m-1)}$</span> 表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于向量 <span class="markdown-them-math-inline">$[f, \dots, f^{(n-1)}, g, \dots, g^{(m-1)}] ^{\mathsf T}$</span> 只有 <span class="markdown-them-math-inline">$n + m$</span> 维<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$(f + g)^{(n + m)}$</span> 必定能由 <span class="markdown-them-math-inline">$f + g, (f + g)^{(1)}, \dots, (f + g)^{(n + m - 1)}$</span> 表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因此我们可以用与维护线性基类似的思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个个插入 <span class="markdown-them-math-inline">$(f + g)^{(k)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后必定可以得到一个  <span class="markdown-them-math-inline">$(f + g)^{(k_0)}$</span> 使得其可以被线性表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$k_0 \le n + m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="$f(x)g(x)$"><span class="markdown-them-math-inline">$f(x)g(x)$</span></h3>
<p>考察 <span class="markdown-them-math-inline">$(fg)^{(k)}$</span> 和 <span class="markdown-them-math-inline">$(fg)^{(k + 1)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若</p>
<p><div class="markdown-them-math-block">$$(fg)^{(k)} = \sum_{i = 0}^{n - 1} \sum_{j = 0}^{m - 1} a_{i,j}(x) f^{(i)} g^{(j)}$$</div></p>
<p>而 <span class="markdown-them-math-inline">$\left(a_{i,j}(x) f^{(i)} g^{(j)}\right)' = a_{i,j}'(x) f^{(i)} g^{(j)} + a_{i,j}(x) f^{(i + 1)} g^{(j)} + a_{i,j}(x) f^{(i)} g^{(j + 1)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并使用微分方程降次可以知道</p>
<p><div class="markdown-them-math-block">$$(fg)^{(k + 1)} = \sum_{i = 0}^{n - 1} \sum_{j = 0}^{m - 1} \left(a_{i,j}(x) f^{(i)} g^{(j)}\right)'$$</div></p>
<p>也符合 <span class="markdown-them-math-inline">$(fg)^{(k)}$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样由归纳法可以知道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们总能将每个 <span class="markdown-them-math-inline">$(f g)^{(k)}$</span> 用 <span class="markdown-them-math-inline">$fg, f^{(1)}g, \dots, f^{(n-1)}g, \dots, f^{(n-2)}g^{(m-1)}, f^{(n-1)}g^{(m-1)}$</span> 表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于以上的分量只有 <span class="markdown-them-math-inline">$n m$</span> 维<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$(f + g)^{(n m)}$</span> 必定能由 <span class="markdown-them-math-inline">$f + g, (f + g)^{(1)}, \dots, (f + g)^{(n m - 1)}$</span> 表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因此我们可以用与维护线性基类似的思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个个插入 <span class="markdown-them-math-inline">$(f + g)^{(k)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后必定可以得到一个  <span class="markdown-them-math-inline">$(f + g)^{(k_0)}$</span> 使得其可以被线性表出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$k_0 \le nm$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="$f-\circ g$"><span class="markdown-them-math-inline">$f \circ g$</span></h3>
<p>这里 <span class="markdown-them-math-inline">$g(x)$</span> 符合一个代数方程 <span class="markdown-them-math-inline">$P(g) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其系数 <span class="markdown-them-math-inline">$\in F_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>若 <span class="markdown-them-math-inline">$\text{deg } P = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$g(x)$</span> 也 <span class="markdown-them-math-inline">$\in F_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时令<br>
<div class="markdown-them-math-block">$$(f\circ g)^{(k)} = \sum_{i = 0}^{n - 1} a_{k,i}(x) \left(f^{(i)} \circ g\right)$$</div><br>
考察 <span class="markdown-them-math-inline">$\left(a_{k,i}(x)\left(f^{(i)} \circ g\right)\right)' = a_{k,i}'(x) \left(f^{(i)} \circ g\right) + a_{k,i}(x) \left(f^{(i + 1)} \circ g\right) g'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$i + 1 = n$</span> 时可以用微分方程降次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即</p>
<p><div class="markdown-them-math-block">$$f^{(n)}\circ g = \sum_{i = 0}^{n - 1} \left(p_i\circ g\right)\left(f^{(i)} \circ g\right)$$</div></p>
<p>若 <span class="markdown-them-math-inline">$\text{deg } P &gt; 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g(x)$</span> 不再具有简单的有理分式形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上面的过程中有两个点无法直接解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>求解 <span class="markdown-them-math-inline">$g'$</span> 和求解每个 <span class="markdown-them-math-inline">$p_i\circ g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>若我们能将 <span class="markdown-them-math-inline">$g'$</span> 表示成关于 <span class="markdown-them-math-inline">$g$</span> 的某个整式 <span class="markdown-them-math-inline">$h(g)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就能直接将其并入前一部分的 <span class="markdown-them-math-inline">$\left(f^{(i + 1)} \circ g\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此下面就是要用 <span class="markdown-them-math-inline">$g$</span> 表出 <span class="markdown-them-math-inline">$g'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>由于 <span class="markdown-them-math-inline">$P(g) = 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其对 <span class="markdown-them-math-inline">$x$</span> 求导得到的应为零函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考察某项 <span class="markdown-them-math-inline">$a_i(x) g^i(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其导数为 <span class="markdown-them-math-inline">$\left(a_i(x) g^i(x)\right)' = a_i'(x) g^i(x) + a_i(x) i g^{i - 1}(x) g'(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前半部分求和得到 <span class="markdown-them-math-inline">$\dfrac{\partial P(t)}{\partial x} \circ g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后半部分求和得到 <span class="markdown-them-math-inline">$\left(\dfrac{\partial P(t)}{\partial t}\circ g\right) g'$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$t$</span> 为占位元<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与 <span class="markdown-them-math-inline">$x$</span> 无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>化简得到</p>
<p><div class="markdown-them-math-block">$$g' = -\dfrac{\partial_x P}{\partial_g P}$$</div></p>
<p>这里视 <span class="markdown-them-math-inline">$P(g, x)$</span> 为二元代数函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$g,x$</span> 彼此无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为降次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把 <span class="markdown-them-math-inline">$g'$</span> <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对应的 <span class="markdown-them-math-inline">$h(g)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对 <span class="markdown-them-math-inline">$P(g)$</span> 取模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>要算的就是同余方程</p>
<p><div class="markdown-them-math-block">$$y\partial_g P \equiv -\partial_x P \pmod{P}$$</div></p>
<p>的解 <span class="markdown-them-math-inline">$y$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可以证明这解必定存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用多项式扩展欧几里得即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>对 <span class="markdown-them-math-inline">$p_i\circ g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以对 <span class="markdown-them-math-inline">$P(g)$</span> 取模来降次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$p_i(x) \in F_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此 <span class="markdown-them-math-inline">$p_i$</span> 分母 <span class="markdown-them-math-inline">$\in F_p[x]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而由于 <span class="markdown-them-math-inline">$P(u)$</span> 代数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其在系数所属的域 <span class="markdown-them-math-inline">$F_p[x]$</span> 上无法分解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>故 <span class="markdown-them-math-inline">$P(u)$</span> 的根都在 <span class="markdown-them-math-inline">$F_p(x) / F_p[x]$</span> 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其和 <span class="markdown-them-math-inline">$p_i(x)$</span> 的分母不存在公因式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以求逆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="实现">实现</h2>
<p>实现了一个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写了 25k<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>全爆炸了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
以 EI 板子为基础构造代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一些细节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有时候实现线性递推并不需要多项式模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但由于一道题一般只有一个模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以和多项式板子共用一个模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
需要系数在 <span class="markdown-them-math-inline">$F_p$</span> 上的多项式 <code>opoly</code> 类维护多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
需要 <span class="markdown-them-math-inline">$F_p(x)$</span> 上的有理分式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义 <code>pfrac</code> 类维护<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
需要系数在 <span class="markdown-them-math-inline">$F_(x)$</span> 上的多项式类维护 ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>令对应的函数 <span class="markdown-them-math-inline">$f(x)$</span> 满足</p>
<p><div class="markdown-them-math-block">$$\sum_{i = 0}^{n} p_i(x) f^{(i)} = 0$$</div></p>
<p>并用 <code>vector&lt;opoly&gt;</code> 维护多项式列 <span class="markdown-them-math-inline">$p_i(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里如果使用 <span class="markdown-them-math-inline">$f^{(n)} = \dots$</span> 的表达形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要维护有理分式列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相对降低直观性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
最后就是用 ODE 返回整式递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及用整式递推 <span class="markdown-them-math-inline">$O(n)$</span> 推导了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>为了不让过长的前导零降低效率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>维护 <code>shrink(T&amp; x)</code> 删除 <span class="markdown-them-math-inline">$x$</span> 的前导零<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
为统一接口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以封装一个 <span class="markdown-them-math-inline">$F_p$</span> 内元素的类 <code>Z</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在底层采用取模优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于此处常数瓶颈并非 ntt 而是线性的取模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>预计这样的优化会减小常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>使用单个常数初始化 <code>opoly</code> 会得到对应常数长度的零多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到常单项式 <span class="markdown-them-math-inline">$c$</span> 需要使用语法 <code>opoly(1, c)</code> 或直接使用 <code>&#123;Z(c)&#125;</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在隐性类型转换时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如多项式除以 int 等处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>尤其要小心<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里也暴露了一个问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>多项式本体 <code>poly</code> 的系数是 <code>u32</code> 类型的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并非 <code>opoly</code> 的 <code>Z</code> 类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要在推导的某个阶段逐渐将 <code>opoly</code> 逐步更换为 <code>poly</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便于整式递推的获得与结果的处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个阶段难以确定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此不妨定义成员函数 <code>trans_prec</code> 返回 <code>poly</code> 盛放的整式递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
目前认为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 ODE 处理的全部内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括 <span class="markdown-them-math-inline">$+\times\circ$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到整式递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行 <span class="markdown-them-math-inline">$O(n)$</span> 递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>均封装为 <code>ODE</code> 的成员函数会相对增加直观性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="使用方法">使用方法</h2>
<p>先把板子放在这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>需要使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/-/polynomial">多项式类 <code>poly</code></a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但功能似乎不是很大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>code</summary>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FastMod</span> &#123;</span>
   <span class="hljs-keyword">int</span> m; ll b;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _m = <span class="hljs-number">1</span>)</span> </span>&#123; m = _m; <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) m = <span class="hljs-number">1</span>; b = ((lll)<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">64</span>) / m; &#125; 
   <span class="hljs-built_in">FastMod</span>(<span class="hljs-keyword">int</span> _m = <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">init</span>(_m); &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ll a)</span> </span>&#123; ll q = ((lll)a * b) &gt;&gt; <span class="hljs-number">64</span>; a -= q * m; <span class="hljs-keyword">if</span> (a &gt;= m) a -= m; <span class="hljs-keyword">return</span> a; &#125;
&#125; <span class="hljs-built_in">Mod</span>(mod);
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Z</span> &#123;</span>
   u32 v;
   <span class="hljs-built_in">Z</span>(u32 v = <span class="hljs-number">0</span>) : <span class="hljs-built_in">v</span>(v) &#123;&#125;
   <span class="hljs-built_in">Z</span>(<span class="hljs-keyword">int</span> v) : <span class="hljs-built_in">v</span>(<span class="hljs-built_in">Norm</span>(<span class="hljs-built_in">Mod</span>(v) + mod)) &#123; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs.v + rhs.v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs.v + rhs); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lhs, <span class="hljs-keyword">const</span> Z&amp; rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs + rhs.v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs.v + mod - rhs.v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs.v - rhs + mod); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lhs, <span class="hljs-keyword">const</span> Z&amp; rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(lhs - rhs.v + mod); &#125;
   <span class="hljs-keyword">inline</span> Z <span class="hljs-keyword">operator</span>-() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Norm</span>(mod - v); &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> Z <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(*<span class="hljs-keyword">this</span>, mod - <span class="hljs-number">2</span>); &#125;;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> Z&amp; rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs.v * rhs.v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs.v * rhs); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lhs, <span class="hljs-keyword">const</span> Z&amp; rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs * rhs.v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs.v * rhs.<span class="hljs-built_in">inv</span>().v); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> Z&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs.v * <span class="hljs-built_in">qp</span>(rhs, mod - <span class="hljs-number">2</span>)); &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> Z <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lhs, <span class="hljs-keyword">const</span> Z&amp; rhs) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Mod</span>(<span class="hljs-number">1ll</span> * lhs * rhs.<span class="hljs-built_in">inv</span>().v); &#125;
   <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">u32</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> v; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;out, <span class="hljs-keyword">const</span> Z &amp;x) &#123; <span class="hljs-keyword">return</span> out &lt;&lt; x.v; &#125;
&#125;;
<span class="hljs-keyword">inline</span> Z &amp;<span class="hljs-keyword">operator</span>+=(Z &amp;lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> lhs = lhs + rhs; &#125;
<span class="hljs-keyword">inline</span> Z &amp;<span class="hljs-keyword">operator</span>-=(Z &amp;lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> lhs = lhs - rhs; &#125;
<span class="hljs-keyword">inline</span> Z &amp;<span class="hljs-keyword">operator</span>*=(Z &amp;lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> lhs = lhs * rhs; &#125;
<span class="hljs-keyword">inline</span> Z &amp;<span class="hljs-keyword">operator</span>/=(Z &amp;lhs, <span class="hljs-keyword">const</span> Z &amp;rhs) &#123; <span class="hljs-keyword">return</span> lhs = lhs / rhs; &#125;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">opoly</span> :</span> vector&lt;Z&gt; &#123;
   <span class="hljs-built_in">opoly</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n = <span class="hljs-number">1</span>, <span class="hljs-keyword">const</span> Z&amp; val = <span class="hljs-number">0</span>) : <span class="hljs-built_in">vector</span>(n, val) &#123;&#125;
   <span class="hljs-built_in">opoly</span>(<span class="hljs-keyword">const</span> initializer_list&lt;value_type&gt; &amp;il) : <span class="hljs-built_in">vector</span>(il) &#123;&#125;
   <span class="hljs-built_in">opoly</span>(<span class="hljs-keyword">const</span> vector&lt;Z&gt; &amp;il) : <span class="hljs-built_in">vector</span>(il) &#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">degree</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) <span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">shrink</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">size</span>(); <span class="hljs-keyword">while</span> (k &amp;&amp; !<span class="hljs-built_in">at</span>(k - <span class="hljs-number">1</span>)) --k; <span class="hljs-built_in">resize</span>(k); <span class="hljs-keyword">return</span> k; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redegree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span>&amp; n)</span> </span>&#123; <span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>); &#125;
   <span class="hljs-keyword">inline</span> opoly <span class="hljs-keyword">operator</span>-() <span class="hljs-keyword">const</span> &#123; <span class="hljs-function">opoly <span class="hljs-title">ret</span><span class="hljs-params">(size())</span></span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>(); ++i) ret[i] = -<span class="hljs-built_in">at</span>(i); <span class="hljs-keyword">return</span> ret; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">poly</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-function">poly <span class="hljs-title">ret</span><span class="hljs-params">(size())</span></span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">size</span>(); ++ i) ret[i] = <span class="hljs-built_in">u32</span>(<span class="hljs-built_in">at</span>(i)); <span class="hljs-keyword">return</span> ret; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> opoly &amp;b) &#123;
      <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">degree</span>(), m = b.<span class="hljs-built_in">degree</span>();
      <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span> || m == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">opoly</span>();
      <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(n + m + <span class="hljs-number">1</span>)</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + m; ++i)
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i - m); j &lt;= <span class="hljs-built_in">min</span>(i, n); ++j)
            c[i] += a[j] * b[i - j];
      <span class="hljs-keyword">return</span> c;
   &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> Z &amp;z) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; <span class="hljs-keyword">for</span> (Z &amp;x : c) x *= z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Z &amp;z, <span class="hljs-keyword">const</span> opoly &amp;a) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; <span class="hljs-keyword">for</span> (Z &amp;x : c) x *= z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> opoly &amp;b) &#123;
      <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(max(a.size(), b.size()))</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) c[i] += a[i];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); ++i) c[i] += b[i];
      <span class="hljs-keyword">return</span> c;
   &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> opoly &amp;b) &#123; <span class="hljs-keyword">return</span> a + -b; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> Z &amp;z) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; c[<span class="hljs-number">0</span>] += z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Z &amp;z, <span class="hljs-keyword">const</span> opoly &amp;a) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; c[<span class="hljs-number">0</span>] += z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> Z &amp;z) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; c[<span class="hljs-number">0</span>] -= z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> opoly <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Z &amp;z, <span class="hljs-keyword">const</span> opoly &amp;a) &#123; <span class="hljs-function">opoly <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>; c[<span class="hljs-number">0</span>] -= z; <span class="hljs-keyword">return</span> c; &#125;
   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> opoly &amp;a, <span class="hljs-keyword">const</span> opoly &amp;b) &#123; 
      <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++ i)  <span class="hljs-keyword">if</span> (a[i] != b[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
   &#125;
   <span class="hljs-function">opoly <span class="hljs-title">deri</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
      <span class="hljs-function">opoly <span class="hljs-title">a</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) a[i - <span class="hljs-number">1</span>] = a[i] * i;
      a.<span class="hljs-built_in">pop_back</span>();
      <span class="hljs-keyword">return</span> a;
   &#125;
   <span class="hljs-function">Z <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Z &amp;z)</span> <span class="hljs-keyword">const</span> </span>&#123;
      Z v = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">degree</span>(); i &gt;= <span class="hljs-number">0</span>; --i) v = v * z + <span class="hljs-built_in">at</span>(i);
      <span class="hljs-keyword">return</span> v;
   &#125;
&#125;;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _vi&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> opoly <span class="hljs-title">topoly</span><span class="hljs-params">(<span class="hljs-keyword">const</span> _vi&amp; a)</span> </span>&#123;
   <span class="hljs-function">opoly <span class="hljs-title">ret</span><span class="hljs-params">(a.size())</span></span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++ i) 
      ret[i].v = a[i];
   <span class="hljs-keyword">return</span> ret;
&#125;
<span class="hljs-function"><span class="hljs-keyword">inline</span> opoly <span class="hljs-title">gcd</span><span class="hljs-params">(opoly a, opoly b)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (!a.<span class="hljs-built_in">shrink</span>()) <span class="hljs-keyword">return</span> b;
   <span class="hljs-keyword">if</span> (!b.<span class="hljs-built_in">shrink</span>()) <span class="hljs-keyword">return</span> a;
   <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(a, b);
   <span class="hljs-keyword">while</span> (b.<span class="hljs-built_in">shrink</span>()) &#123;
      Z in = b.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">inv</span>();
      <span class="hljs-keyword">for</span> (Z &amp;x : b) x *= in;
      <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">degree</span>(), m = b.<span class="hljs-built_in">degree</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= m; --i) &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)
            a[i - j] -= a[i] * b[m - j];
         a[i] = <span class="hljs-number">0</span>;
      &#125; <span class="hljs-built_in">swap</span>(a, b);
   &#125; <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">shrink</span>(), a;
&#125;
<span class="hljs-function"><span class="hljs-keyword">inline</span> opoly <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">const</span> opoly&amp; _a, <span class="hljs-keyword">const</span> opoly&amp; _b)</span> </span>&#123;
   <span class="hljs-function">opoly <span class="hljs-title">a</span><span class="hljs-params">(_a)</span>, <span class="hljs-title">b</span><span class="hljs-params">(_b)</span></span>;
   Z in = b.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">inv</span>();
   <span class="hljs-keyword">for</span> (Z &amp;x : b) x *= in;
   <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">degree</span>(), m = b.<span class="hljs-built_in">degree</span>();
   <span class="hljs-function">opoly <span class="hljs-title">ret</span><span class="hljs-params">(n - m + <span class="hljs-number">1</span>)</span></span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= m; --i) &#123;
      ret[i - m] = a[i] * b[m];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)
         a[i - j] -= a[i] * b[m - j];
   &#125; <span class="hljs-keyword">for</span> (Z &amp;x : ret) x = x * in;
   <span class="hljs-keyword">return</span> ret;
&#125;
<span class="hljs-keyword">inline</span> opoly <span class="hljs-keyword">operator</span>/ (<span class="hljs-keyword">const</span> opoly&amp; _a, <span class="hljs-keyword">const</span> opoly&amp; _b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">div</span>(_a, _b); &#125;
<span class="hljs-keyword">inline</span> opoly&amp; <span class="hljs-keyword">operator</span>/= (opoly&amp; _a, <span class="hljs-keyword">const</span> opoly&amp; _b) &#123; _a = <span class="hljs-built_in">div</span>(_a, _b); <span class="hljs-keyword">return</span> _a; &#125;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pfrac</span> &#123;</span>
   opoly x, y;
   <span class="hljs-built_in">pfrac</span>(<span class="hljs-keyword">const</span> opoly &amp;x = <span class="hljs-built_in">opoly</span>(), <span class="hljs-keyword">const</span> opoly &amp;y = &#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;
   <span class="hljs-keyword">inline</span> pfrac <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">pfrac</span>(x * rhs.y + y * rhs.x, y * rhs.y); &#125;
   <span class="hljs-keyword">inline</span> pfrac <span class="hljs-keyword">operator</span>-() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">pfrac</span>(-x, y); &#125;
   <span class="hljs-keyword">inline</span> pfrac <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> + -rhs; &#125;
   <span class="hljs-keyword">inline</span> pfrac <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">pfrac</span>(x * rhs.x, y * rhs.y); &#125;
   <span class="hljs-comment">// inline pfrac operator*(const Z &amp;rhs) const &#123; return pfrac(x * rhs, y * rhs); &#125; // ?</span>
   <span class="hljs-function"><span class="hljs-keyword">inline</span> pfrac <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">pfrac</span>(y, x); &#125;
   <span class="hljs-keyword">inline</span> pfrac <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * rhs.<span class="hljs-built_in">inv</span>(); &#125;
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> x * rhs.y == y * rhs.x; &#125;
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> pfrac &amp;rhs) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(rhs); &#125;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">()</span> </span>&#123;
      y.<span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">if</span> (!x.<span class="hljs-built_in">shrink</span>()) &#123; y = opoly&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;; <span class="hljs-keyword">return</span>; &#125;
      opoly g = <span class="hljs-built_in">gcd</span>(x, y);
      x /= g, y /= g;
   &#125;
   <span class="hljs-function">pfrac <span class="hljs-title">deri</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">pfrac</span>(x.<span class="hljs-built_in">deri</span>() * y - y.<span class="hljs-built_in">deri</span>() * x, y * y); &#125;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Q_Basis</span> &#123;</span>
   <span class="hljs-keyword">int</span> dim, id;
   vector&lt;vector&lt;pfrac&gt; &gt; basis, augment;
   <span class="hljs-built_in">Q_Basis</span>(<span class="hljs-keyword">int</span> dim) : <span class="hljs-built_in">dim</span>(dim), <span class="hljs-built_in">id</span>(), <span class="hljs-built_in">basis</span>(dim), <span class="hljs-built_in">augment</span>(dim) &#123;&#125;
   <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">insert</span><span class="hljs-params">(vector&lt;pfrac&gt; vec)</span> </span>&#123;
      <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(dim + <span class="hljs-number">1</span>)</span></span>;
      tmp[id++] = <span class="hljs-built_in">pfrac</span>(&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i) &#123;
         <span class="hljs-keyword">if</span> (vec[i] != <span class="hljs-built_in">pfrac</span>()) &#123;
            <span class="hljs-keyword">if</span> (basis[i].<span class="hljs-built_in">empty</span>()) &#123;
               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; dim; ++j) &#123;
                  vec[j] = vec[j] / vec[i];
                  vec[j].<span class="hljs-built_in">shrink</span>();
               &#125;
               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; id; ++j) &#123;
                  tmp[j] = tmp[j] / vec[i];
                  tmp[j].<span class="hljs-built_in">shrink</span>();
               &#125;
               vec[i] = <span class="hljs-built_in">pfrac</span>(&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
               basis[i] = vec;
               augment[i] = tmp;
               <span class="hljs-keyword">return</span> &#123;&#125;;
            &#125; <span class="hljs-keyword">else</span> &#123;
               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; dim; ++j)
                  vec[j] = vec[j] - vec[i] * basis[i][j];
               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; id; ++j)
                  tmp[j] = tmp[j] - vec[i] * augment[i][j];
               vec[i] = <span class="hljs-built_in">pfrac</span>();
            &#125;
         &#125;
      &#125; <span class="hljs-keyword">return</span> tmp;
   &#125;
&#125;;

<span class="hljs-keyword">using</span> PRec = vector&lt;opoly&gt;;
<span class="hljs-keyword">using</span> ODE_base = vector&lt;opoly&gt;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ODE</span> &#123;</span>
   ODE_base ode;
   <span class="hljs-built_in">ODE</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n = <span class="hljs-number">1</span>, <span class="hljs-keyword">const</span> opoly&amp; val = &#123;<span class="hljs-number">0</span>&#125;) : <span class="hljs-built_in">ode</span>(n, val) &#123;&#125;
   <span class="hljs-built_in">ODE</span>(<span class="hljs-keyword">const</span> initializer_list&lt;opoly&gt; &amp;il) : <span class="hljs-built_in">ode</span>(il) &#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ode.<span class="hljs-built_in">size</span>(); &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">degree</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; &#125;
   <span class="hljs-keyword">inline</span> opoly&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> x) &#123; <span class="hljs-keyword">return</span> ode[x]; &#125;
   <span class="hljs-keyword">inline</span> opoly <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> x) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> ode[x]; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> ODE&amp; <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> ode.<span class="hljs-built_in">resize</span>(x), *<span class="hljs-keyword">this</span>; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> ODE&amp; <span class="hljs-title">redegree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> ode.<span class="hljs-built_in">resize</span>(x + <span class="hljs-number">1</span>), *<span class="hljs-keyword">this</span>; &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> ODE_base::iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ode.<span class="hljs-built_in">begin</span>(); &#125;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> ODE_base::iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ode.<span class="hljs-built_in">end</span>(); &#125;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">()</span> </span>&#123;
      opoly g = <span class="hljs-built_in">opoly</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span> (opoly &amp;x : ode) x.<span class="hljs-built_in">shrink</span>(), g = <span class="hljs-built_in">gcd</span>(g, x);
      <span class="hljs-keyword">for</span> (opoly &amp;x : ode) <span class="hljs-keyword">if</span> (!x.<span class="hljs-built_in">empty</span>()) x = <span class="hljs-built_in">div</span>(x, g);
   &#125;
   <span class="hljs-function">ODE <span class="hljs-title">deri</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;
      ODE _ode(*<span class="hljs-keyword">this</span>);
      _ode.<span class="hljs-built_in">resize</span>(_ode.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) _ode.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;
         _ode[i + <span class="hljs-number">1</span>] = _ode[i + <span class="hljs-number">1</span>] + _ode[i];
         _ode[i] = _ode[i].<span class="hljs-built_in">deri</span>();
      &#125; <span class="hljs-keyword">return</span> _ode;
   &#125;
   <span class="hljs-function">ODE <span class="hljs-title">theta</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;
      ODE _ode(<span class="hljs-built_in">deri</span>());
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _ode.<span class="hljs-built_in">size</span>(); ++i) _ode[i] = _ode[i] * opoly&#123;<span class="hljs-built_in">Z</span>(), <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
      <span class="hljs-keyword">return</span> _ode;
   &#125;

   PRec _rec;
   vector&lt;Z&gt; coef;
   <span class="hljs-function"><span class="hljs-keyword">inline</span> PRec <span class="hljs-title">getPRec</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">int</span> tmp = numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">max</span>();
      <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">degree</span>(), m = numeric_limits&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">min</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;
         <span class="hljs-keyword">if</span> (ode[i].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;
         m = <span class="hljs-built_in">max</span>(m, (<span class="hljs-keyword">int</span>) ode[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i);
         <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">while</span> (ode[i][j] == <span class="hljs-number">0</span>) ++j;
         tmp = <span class="hljs-built_in">min</span>(tmp, j - i);
      &#125; m -= tmp;
      <span class="hljs-function">PRec <span class="hljs-title">rec</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, opoly(n + <span class="hljs-number">1</span>))</span></span>; opoly fall&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;
         opoly coef = fall;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>) ode[i].<span class="hljs-built_in">size</span>() - i - tmp; ++j) &#123;
            <span class="hljs-keyword">if</span> (j + i + tmp &gt;= <span class="hljs-number">0</span>) rec[j] = rec[j] + coef * ode[i][j + i + tmp];
            coef = <span class="hljs-built_in">div</span>(coef * opoly&#123;-<span class="hljs-built_in">Z</span>(i + j), <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;, opoly&#123;-<span class="hljs-built_in">Z</span>(j), <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
         &#125; fall = fall * opoly&#123;-<span class="hljs-built_in">Z</span>(i), <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
      &#125; 
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) rec[i].<span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">return</span> _rec = rec;
   &#125;
   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
      coef.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)
         coef[i] = _rec[<span class="hljs-number">0</span>].<span class="hljs-built_in">eval</span>(i);
      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i)
         <span class="hljs-keyword">if</span> (coef[i] == <span class="hljs-number">0</span>) &#123;
            r = i;
            <span class="hljs-keyword">break</span>;
         &#125;
      <span class="hljs-keyword">return</span> r;
   &#125;
   <span class="hljs-function">opoly <span class="hljs-title">post</span><span class="hljs-params">(opoly init)</span> </span>&#123;
      <span class="hljs-keyword">int</span> m = init.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">auto</span> invs = [&amp;](<span class="hljs-keyword">const</span> opoly &amp;vec) &#123;
         opoly <span class="hljs-built_in">prf</span>(vec.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">ret</span>(vec.<span class="hljs-built_in">size</span>());
         prf[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); ++i) prf[i] = prf[i - <span class="hljs-number">1</span>] * vec[i - <span class="hljs-number">1</span>];
         Z tot = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>), multiplies&lt;Z&gt;()).<span class="hljs-built_in">inv</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>) vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) ret[i] = tot * prf[i], tot *= vec[i];
         <span class="hljs-keyword">return</span> ret;
      &#125;;
      <span class="hljs-keyword">auto</span> nvs = <span class="hljs-built_in">invs</span>(vector&lt;Z&gt;(coef.<span class="hljs-built_in">begin</span>() + m, coef.<span class="hljs-built_in">end</span>()));
      init.<span class="hljs-built_in">resize</span>(coef.<span class="hljs-built_in">size</span>());
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &lt; coef.<span class="hljs-built_in">size</span>(); ++i) &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">min</span>(i + <span class="hljs-number">1</span>, (<span class="hljs-keyword">int</span>) _rec.<span class="hljs-built_in">size</span>()); ++j)
            init[i] += init[i - j] * _rec[j].<span class="hljs-built_in">eval</span>(i);
         init[i] = init[i] * -nvs[i - m];
      &#125; <span class="hljs-keyword">return</span> init;
   &#125;
   <span class="hljs-function">poly <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n, <span class="hljs-keyword">const</span> poly&amp; a0)</span> </span>&#123;
      <span class="hljs-built_in">getPRec</span>();
      <span class="hljs-built_in">prf</span>(n);
      <span class="hljs-function">opoly <span class="hljs-title">ret</span><span class="hljs-params">(a0.size())</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a0.<span class="hljs-built_in">size</span>(); ++ i) ret[i].v = a0[i];
      <span class="hljs-keyword">if</span> (n &lt;= ret.<span class="hljs-built_in">degree</span>()) <span class="hljs-keyword">return</span> ret.<span class="hljs-built_in">redegree</span>(n), ret;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">post</span>(ret);
   &#125;
   <span class="hljs-function">vector&lt;poly&gt; <span class="hljs-title">trans_poly</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-function">vector&lt;poly&gt; <span class="hljs-title">ret</span><span class="hljs-params">(_rec.size(), poly())</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _rec.<span class="hljs-built_in">size</span>(); ++ i) 
         _rec[i].<span class="hljs-built_in">shrink</span>(), ret[i] = _rec[i];
      <span class="hljs-keyword">return</span> ret;
   &#125;

   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> ODE <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> ODE &amp;op, <span class="hljs-keyword">const</span> ODE &amp;oq) &#123;
      <span class="hljs-keyword">int</span> n = op.<span class="hljs-built_in">degree</span>(), m = oq.<span class="hljs-built_in">degree</span>();
      <span class="hljs-function">Q_Basis <span class="hljs-title">basis</span><span class="hljs-params">(n + m)</span></span>;
      <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">pd</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">qd</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;
      pd[<span class="hljs-number">0</span>] = qd[<span class="hljs-number">0</span>] = <span class="hljs-built_in">pfrac</span>(&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dim = <span class="hljs-number">0</span>; dim &lt;= n + m; ++dim) &#123;
         <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n + m)</span></span>;
         <span class="hljs-built_in">copy</span>(pd.<span class="hljs-built_in">begin</span>(), pd.<span class="hljs-built_in">begin</span>() + n, vec.<span class="hljs-built_in">begin</span>());
         <span class="hljs-built_in">copy</span>(qd.<span class="hljs-built_in">begin</span>(), qd.<span class="hljs-built_in">begin</span>() + m, vec.<span class="hljs-built_in">begin</span>() + n);
         <span class="hljs-keyword">auto</span> ret = basis.<span class="hljs-built_in">insert</span>(vec);
         <span class="hljs-keyword">if</span> (!ret.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-function">ODE <span class="hljs-title">ode</span><span class="hljs-params">(dim + <span class="hljs-number">1</span>)</span></span>; opoly prod = &#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i) prod = prod * ret[i].y;
            ode[dim] = prod;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i) ode[i] = ret[i].x * <span class="hljs-built_in">div</span>(prod, ret[i].y);
            ode.<span class="hljs-built_in">shrink</span>();
            <span class="hljs-keyword">return</span> ode;
         &#125; pd[n] = qd[m] = <span class="hljs-built_in">pfrac</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) pd[j + <span class="hljs-number">1</span>] = pd[j + <span class="hljs-number">1</span>] + pd[j], pd[j] = pd[j].<span class="hljs-built_in">deri</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) qd[j + <span class="hljs-number">1</span>] = qd[j + <span class="hljs-number">1</span>] + qd[j], qd[j] = qd[j].<span class="hljs-built_in">deri</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) pd[j] = pd[j] - pd[n] * op[j] / op[n], pd[j].<span class="hljs-built_in">shrink</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) qd[j] = qd[j] - qd[m] * oq[j] / oq[m], qd[j].<span class="hljs-built_in">shrink</span>();
      &#125;
   &#125;

   <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> ODE <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> ODE &amp;op, <span class="hljs-keyword">const</span> ODE &amp;oq) &#123;
      <span class="hljs-keyword">int</span> n = op.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, m = oq.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
      <span class="hljs-function">Q_Basis <span class="hljs-title">basis</span><span class="hljs-params">(n * m)</span></span>;
      vector&lt;vector&lt;pfrac&gt; &gt; <span class="hljs-built_in">p</span>(n + <span class="hljs-number">1</span>, vector&lt;pfrac&gt;(m + <span class="hljs-number">1</span>));
      p[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">pfrac</span>(&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> dim = <span class="hljs-number">0</span>; dim &lt;= n * m; ++dim) &#123;
         <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n * m)</span></span>;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)
               vec[i * m + j] = p[i][j];
         <span class="hljs-keyword">auto</span> ret = basis.<span class="hljs-built_in">insert</span>(vec);
         <span class="hljs-keyword">if</span> (!ret.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-function">ODE <span class="hljs-title">ode</span><span class="hljs-params">(dim + <span class="hljs-number">1</span>)</span></span>; opoly prod = &#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i) prod = prod * ret[i].y;
            ode[dim] = prod;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i) ode[i] = ret[i].x * <span class="hljs-built_in">div</span>(prod, ret[i].y);
            ode.<span class="hljs-built_in">shrink</span>();
            <span class="hljs-keyword">return</span> ode;
         &#125;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) p[i][m] = <span class="hljs-built_in">pfrac</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) p[n][j] = <span class="hljs-built_in">pfrac</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;
               p[i + <span class="hljs-number">1</span>][j] = p[i + <span class="hljs-number">1</span>][j] + p[i][j];
               p[i][j + <span class="hljs-number">1</span>] = p[i][j + <span class="hljs-number">1</span>] + p[i][j];
               p[i][j] = p[i][j].<span class="hljs-built_in">deri</span>();
            &#125;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) 
               p[i][j] = p[i][j] - p[n][j] * op[i] / op[n] - p[i][m] * oq[j] / oq[m], p[i][j].<span class="hljs-built_in">shrink</span>();
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">inline</span> ODE <span class="hljs-title">composite</span><span class="hljs-params">(pfrac q)</span> <span class="hljs-keyword">const</span> </span>&#123;
      q.<span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">int</span> n = ode.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
      vector&lt;vector&lt;pfrac&gt;&gt; <span class="hljs-built_in">tri</span>(n + <span class="hljs-number">1</span>, vector&lt;pfrac&gt;(n + <span class="hljs-number">1</span>));
      tri[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">pfrac</span>(&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;);
      pfrac d = q.<span class="hljs-built_in">deri</span>();
      d.<span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; ++j) &#123;
            tri[i + <span class="hljs-number">1</span>][j] = tri[i + <span class="hljs-number">1</span>][j] + tri[i][j].<span class="hljs-built_in">deri</span>();
            tri[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = tri[i][j] * d;
         &#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i + <span class="hljs-number">1</span>; ++j) tri[i + <span class="hljs-number">1</span>][j].<span class="hljs-built_in">shrink</span>();
      &#125; <span class="hljs-function">vector&lt;pfrac&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) 
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = ode[i].<span class="hljs-built_in">degree</span>(); j &gt;= <span class="hljs-number">0</span>; --j) vec[i] = vec[i] * q + <span class="hljs-built_in">pfrac</span>(&#123;ode[i][j]&#125;), vec[i].<span class="hljs-built_in">shrink</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; --i) &#123;
         vec[i] = vec[i] / tri[i][i], vec[i].<span class="hljs-built_in">shrink</span>();
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)  vec[j] = vec[j] - vec[i] * tri[i][j];
      &#125; opoly prod = opoly&#123;<span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)&#125;;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) prod = prod * vec[i].y;
      <span class="hljs-function">ODE <span class="hljs-title">ret</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) ret[i] = vec[i].x * <span class="hljs-built_in">div</span>(prod, vec[i].y);
      <span class="hljs-keyword">return</span> ret.<span class="hljs-built_in">shrink</span>(), ret;
   &#125;
&#125;;
<span class="hljs-function">ODE <span class="hljs-title">linear_add</span><span class="hljs-params">(ODE a, ODE b)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(a, b);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); ++i) a[i] = a[i] + b[i];
   <span class="hljs-keyword">return</span> a;
&#125;
<span class="hljs-function">ODE <span class="hljs-title">scalar_mul</span><span class="hljs-params">(ODE ode, <span class="hljs-keyword">const</span> Z &amp;z)</span> </span>&#123;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ode.<span class="hljs-built_in">size</span>(); ++i)
      ode[i] = ode[i] * z;
   <span class="hljs-keyword">return</span> ode;
&#125;

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Z &amp;q) &#123; <span class="hljs-keyword">return</span> out &lt;&lt; q.v; &#125;
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> opoly &amp;p) &#123;
   <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> out &lt;&lt; <span class="hljs-number">0</span>;
   out &lt;&lt; p[<span class="hljs-number">0</span>]; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; p.<span class="hljs-built_in">size</span>(); ++i)
      out &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&quot;x^&quot;</span> &lt;&lt; i;
   <span class="hljs-keyword">return</span> out;
&#125;
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> pfrac &amp;q) &#123; <span class="hljs-keyword">return</span> out &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; q.x &lt;&lt; <span class="hljs-string">&quot;) / (&quot;</span> &lt;&lt; q.y &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>; &#125;
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> ODE &amp;ode) &#123;
   out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; ode[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;)F&quot;</span>;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; ode.<span class="hljs-built_in">size</span>(); ++i) &#123;
      out &lt;&lt; <span class="hljs-string">&quot; + (&quot;</span> &lt;&lt; ode[i] &lt;&lt; <span class="hljs-string">&quot;)F^&#123;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;)&#125;&quot;</span>;
   &#125; <span class="hljs-keyword">return</span> out &lt;&lt; <span class="hljs-string">&quot; = 0&quot;</span>;
&#125;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> vector&lt;T&gt; &amp;v) &#123;
   <span class="hljs-keyword">if</span> (!v.<span class="hljs-built_in">empty</span>()) &#123;
      out &lt;&lt; v.<span class="hljs-built_in">front</span>();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) out &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; v[i];
   &#125; <span class="hljs-keyword">return</span> out;
&#125;
ostream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(ostream &amp;in, <span class="hljs-keyword">const</span> Z &amp;q) &#123; <span class="hljs-keyword">return</span> in &gt;&gt; q.v; &#125;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is, vector&lt;T&gt; &amp;v) &#123; <span class="hljs-keyword">for</span> (T &amp;x : v) is &gt;&gt; x; <span class="hljs-keyword">return</span> is; &#125;

<span class="hljs-keyword">const</span> ODE ODE_EXP = &lt;!--swig￼<span class="hljs-number">0</span>--&gt;; &#125;
<span class="hljs-function">ODE <span class="hljs-title">ode_bessel</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Z &amp;k)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ODE</span>(&lt;!--swig￼<span class="hljs-number">1</span>--&gt;); &#125;
<span class="hljs-function">ODE <span class="hljs-title">ode_pFq</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;Z&gt; &amp;a, <span class="hljs-keyword">const</span> vector&lt;Z&gt; &amp;b)</span> </span>&#123;
   ODE l = &lt;!--swig￼<span class="hljs-number">2</span>--&gt;, r = l;
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : a) l = <span class="hljs-built_in">linear_add</span>(l.<span class="hljs-built_in">theta</span>(), <span class="hljs-built_in">scalar_mul</span>(l, x));
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : b) r = <span class="hljs-built_in">linear_add</span>(r.<span class="hljs-built_in">theta</span>(), <span class="hljs-built_in">scalar_mul</span>(r, x - <span class="hljs-number">1</span>));
   ODE ret = <span class="hljs-built_in">linear_add</span>(r.<span class="hljs-built_in">deri</span>(), <span class="hljs-built_in">scalar_mul</span>(l, - <span class="hljs-built_in">Z</span>(<span class="hljs-number">1</span>)));
   <span class="hljs-keyword">return</span> ret.<span class="hljs-built_in">shrink</span>(), ret;
&#125; 
</code></pre></div>
</details>
<p>化简某个类可以使用成员函数 <code>shrink()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<code>struct Z</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>用来维护模 <span class="markdown-them-math-inline">$\text{mod}$</span> 意义下一个数的类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 <code>struct FastMod</code> 进行底层乘法优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<code>struct opoly</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>继承了类 <code>vector&lt;Z&gt;</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来维护短多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于模数可能不是多项式模数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>底层使用 <span class="markdown-them-math-inline">$O(n^2)$</span> 多项式乘法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>封装了基础多项式运算 <span class="markdown-them-math-inline">$+-\times /$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>成员函数求导 <code>deri()</code> 和求值 <code>eval(int x)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>朴素的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>多项式欧几里得 <code>gcd(opoly, opoly)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<code>struct pfrac</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>用来维护有理分式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分子与分母均为 <code>opoly</code> 类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别命名为 x 和 y<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>封装了基础运算 <span class="markdown-them-math-inline">$+-\times /$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>成员函数求导 <code>deri()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<code>struct Q_Basis</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>用来维护类似线性基的结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便于 ODE 的加法与乘法的进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><code>struct ODE</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>大的来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>这个是三合一<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以通过调用成员函数实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>ODE 的 <span class="markdown-them-math-inline">$+\times \circ$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及由 ODE 求解整式递推系数多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>还有线性递推出前 <span class="markdown-them-math-inline">$n$</span> 项系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个个说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
上面提到的 ODE 的加法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>乘法可以直接用运算符进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而复合需要调用成员函数 <code>composite(pfrac)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意这里只能复合有理分式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
由 ODE 求解整式递推<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要调用 <code>getPRec()</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到的整式递推会被存在 ODE 类里的 <code>_rec</code><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这是个 <code>vector&lt;opoly&gt;</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其存放方式与<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6115"><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>模板<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>整式递推</a>中相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但如果我们想调用 <span class="markdown-them-math-inline">$O(\sqrt n \log n)$</span> 自动机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要将其转为 <code>vector&lt;poly&gt;</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用成员函数 <code>trans_poly()</code> 接收返回值即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>与 <span class="markdown-them-math-inline">$O(\sqrt n \log n)$</span> 自动机的配合只需要把需要的值求出来即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
线性递推出前 <span class="markdown-them-math-inline">$n$</span> 项系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 <code>recur(const int&amp; n, const poly&amp; a0)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <code>a0</code> 存放初值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其返回 <span class="markdown-them-math-inline">$a_0, \dots, a_n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并存放在一个 <code>poly</code> 中返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>一些基础函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<code>const ODE ODE_EXP</code> 对应的是 <span class="markdown-them-math-inline">$\exp x$</span> 的 ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><br>
<code>const ODE ODE_LN</code> 对应的是 <span class="markdown-them-math-inline">$-\ln (1-x)$</span> 的 ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><br>
<code>ODE ode_power(int k)</code> 对应的是 <span class="markdown-them-math-inline">$x^k$</span> 的 ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span><br>
<code>ODE ode_pFq(const vector&lt;Z&gt; &amp;a, const vector&lt;Z&gt; &amp;b)</code> 对应的是 <span class="markdown-them-math-inline">$F\left(\left.\begin{matrix} a_1,\dots, a_p \\ b_1, \dots, b_q \end{matrix}\right\rvert x\right)$</span> 的 ODE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></p>
<p>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本自动机没有经过压力测试<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能出现不可预测的错误<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="附录">附录</h1>
<h2 id="经典微积分">经典微积分</h2>
<p>请自行阅读<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>高等数学<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>上册<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>获得必要知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里只作列出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 1.1 } \text{(求导) }$</span></p>
<p>定义对函数 <span class="markdown-them-math-inline">$f(x)$</span> 的形式导数 <span class="markdown-them-math-inline">$f'(x)$</span> 满足 <span class="markdown-them-math-inline">$[x^{k-1}] f'(x) = k f[k]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>下面 <span class="markdown-them-math-inline">$f, g$</span> 都是以 <span class="markdown-them-math-inline">$x$</span> 为自变量的一元函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$c$</span> 为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$(cf)' = cf' \quad (f + g)' = f' + g' \quad (f - g)' = f' - g' \quad (fg)' = f'g + g'f \quad (f/g)' = \frac{f'g - g'f}{g^2}$$</div></p>
<p><div class="markdown-them-math-block">$$c' = 0 \quad (x^k)' = kx^{k-1} \quad (a^x)' = a^x \ln a \quad (\log_a x)' = \frac{1}{x\ln a}$$</div><br>
<div class="markdown-them-math-block">$$(\sin x)' = \cos x \quad (\cos x)' = - \sin x \quad (\tan x)' = \sec^2 x $$</div><br>
<div class="markdown-them-math-block">$$ (\sec x)' = \sec x\tan x \quad (\csc x)' = - \csc x \cot x \quad(\cot x)' = -\csc^2 x $$</div><br>
<div class="markdown-them-math-block">$$f(g(x)) = g'(x) f'(g(x))\quad \left(f^{\langle -1\rangle}\right)' = 1 / f'$$</div></p>
<p>记对 <span class="markdown-them-math-inline">$f(x)$</span> 求 <span class="markdown-them-math-inline">$k$</span> 次导数得到的值为 <span class="markdown-them-math-inline">$f^{(k)}(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$(fg)^{(k)} = \sum_{i = 0}^k\binom{k}{i} f^{(i)} g^{(k-i)}$$</div></p>
<p>记函数 <span class="markdown-them-math-inline">$f(x, y)$</span> 对 <span class="markdown-them-math-inline">$x$</span> 求偏导为 <span class="markdown-them-math-inline">$\frac{\partial}{\partial x} f(x, y)$</span>.</p>
<p><div class="markdown-them-math-block">$$\frac{\partial u}{\partial y} \frac{\partial y}{\partial x} = \frac{\partial u}{\partial x}$$</div></p>
<p>求导是操作系数的一个经典方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此定义如下的算子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 1.2 } \text{(}\vartheta\text{ 算子) }$</span></p>
<p>对一个函数 <span class="markdown-them-math-inline">$f(x)$</span> 定义 <span class="markdown-them-math-inline">$\vartheta$</span> 算子 <span class="markdown-them-math-inline">$\vartheta f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\vartheta f(x) = x f'(x)$$</div></p>
<p>可以发现 <span class="markdown-them-math-inline">$[x^k]\vartheta f(x) = kf[k]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>需要注意的是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$0$</span> 次项可能需要重新定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>积分和求导同样重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 1.3 } \text{(积分) }$</span></p>
<p>定义对函数 <span class="markdown-them-math-inline">$f(x)$</span> 的形式积分操作 <span class="markdown-them-math-inline">$\int f(x)$</span> 满足 <span class="markdown-them-math-inline">$[x^{k+1}] \int f(x) = f[k] / (k + 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>下面 <span class="markdown-them-math-inline">$f, g$</span> 都是以 <span class="markdown-them-math-inline">$x$</span> 为自变量的一元函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$c$</span> 为常数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\int (f \pm g) \text dx = \int f(x) \text dx \pm \int g(x) \text dx \quad \int cf(x) \text dx = c\int f(x) \text dx$$</div><br>
<div class="markdown-them-math-block">$$\int g'(f(x)) f'(x) \text dx = g(f(x)) + c \quad (第一类换元法原理)$$</div><br>
<div class="markdown-them-math-block">$$\int f'(x)g(x) \text dx = f(x)g(x) - \int f(x)g'(x)\text dx \quad (分部积分法原理)$$</div></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 1.1 } \text{(洛必达法则) }$</span></p>
<p>若函数 <span class="markdown-them-math-inline">$f(x), g(x)$</span> 满足如下条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$\lim\limits_{x \to a} f(x) = 0, \ \lim\limits_{x \to a} g(x) = 0$</span></li>
<li><span class="markdown-them-math-inline">$f,g$</span> 在点 <span class="markdown-them-math-inline">$a$</span> 的某一去心邻域内可导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$g'(x)\neq 0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$\lim\limits_{x \to a} \dfrac{f'(x)}{g'(x)} = A$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$A \in \mathbb R$</span> 或 <span class="markdown-them-math-inline">$A = \pm \infty$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
则我们有<br>
<div class="markdown-them-math-block">$$\lim_{x \to a} \frac{f(x)}{g(x)} = \lim_{x \to a} \frac{f'(x)}{g'(x)} = A$$</div></li>
</ol>
</blockquote>
<h2 id="离散微积分">离散微积分</h2>
<p>类比经典微分算子 <span class="markdown-them-math-inline">$\text d$</span> 取到无穷小的操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里定义差分算子取到离散情况的最小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当然我们也需要定义点值平移的算子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 2.1 }\text{(差分算子 }\Delta\text { )}$</span></p>
<p>对于一个函数 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义 <span class="markdown-them-math-inline">$\Delta f(x) = f(x + 1) - f(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>经典微分中存在 <span class="markdown-them-math-inline">$\text d (e^x) = e^x\text dx$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在这里存在 <span class="markdown-them-math-inline">$\Delta 2^n = 2^n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 2.2 }\text{(平移算子 E )}$</span></p>
<p>对于一个函数 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义 <span class="markdown-them-math-inline">$\text E f(x) = f(x + 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$\Delta = \text E - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>众所周知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\text d (x^n) = n x^{n-1}\text dx$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那么在离散微积分中有没有类似的函数呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>是有的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们接下来就将阐述这种函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 2.3 }\text{(阶乘幂) }$</span></p>
<p>阶乘幂分为下降幂和上升幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ol>
<li>下降幂 <span class="markdown-them-math-inline">$x^{\underline n} = x(x - 1)(x - 2)\cdots (x - n + 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
当 <span class="markdown-them-math-inline">$n &gt; 0, -n &lt; 0$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$x^{\underline{-n}} = \frac{1}{(x + 1)(x + 2)\cdots (x + n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$x^{\underline{a + b}} = x^{\underline a}(x - a)^{\underline b}$</span></li>
<li>上升幂 <span class="markdown-them-math-inline">$x^{\overline n} = x(x + 1)(x + 2)\cdots (x + n - 1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
当 <span class="markdown-them-math-inline">$n &gt; 0, -n &lt; 0$</span> 的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$x^{\overline{-n}} = \frac{1}{(x - 1)(x - 2)\cdots (x - n)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$x^{\overline{a + b}} = x^{\overline a}(x + a)^{\overline b}$</span><br>
<span class="markdown-them-math-inline">$x^{\underline n} = (-1)^n (- x)^{\overline n}$</span></li>
</ol>
</blockquote>
<p>可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\Delta x^{\underline n} = n x^{\underline {n-1}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>类比经典不定积分算子 <span class="markdown-them-math-inline">$\int$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们也可以使用求和代替不定积分算子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到有限积分<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>通常求和 <span class="markdown-them-math-inline">$[0, n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ \int x^k = \frac{x^{k + 1}}{k + 1} \Rightarrow \sum_{i=0}^{n-1} i^k = \frac{n^{\underline{k + 1}}}{k + 1} $$</div><br>
<div class="markdown-them-math-block">$$ \int \frac 1x = \ln x \Rightarrow \sum_{i=0}^{n-1} i^{\underline {-1}} = \sum_{i=1}^{n} \frac 1i = H_n $$</div></p>
<h2 id="一些具体的级数">一些具体的级数</h2>
<p>在推导的过程中可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这两种广义级数对应的定理从证明方法到具体步骤都是很相似的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时两者之间也有着不小的联系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>参考资料<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/qwaszx/guang-yi-er-xiang-zhi-shuo-ji-shuo">广义二项/指数级数, qwaszx</a><br>
<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>具体数学<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span></p>
<h3 id="广义二项级数">广义二项级数</h3>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 3.1.1 }\text{(广义二项级数)}$</span></p>
<p>定义广义二项级数为</p>
<p><div class="markdown-them-math-block">$$\mathcal{B}_t(z) = \sum_{n \ge 0} \binom{tn + 1}{n} \frac{z^n}{tn + 1} = \sum_{n\ge 0}(tn)^{\underline{n-1}} \frac{z^n}{n!}$$</div></p>
</blockquote>
<p>我们首先需要得到其封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这就需要我们证明如下的定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.1.1 }\text{(封闭形式)}$</span></p>
<p>广义二项级数满足</p>
<p><div class="markdown-them-math-block">$$\mathcal{B}_t(z) = z\mathcal{B}_t(z)^t + 1$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$F(z) = \mathcal{B}_t(z) - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就得到</p>
<p><div class="markdown-them-math-block">$$F(z) = z(F(z) + 1)^t$$</div></p>
<p>这个形式容易构造 <span class="markdown-them-math-inline">$G(z) = F^{\langle -1\rangle} = \dfrac{z}{(1 + z)^t}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$[z^n]F(z) = \frac 1n [z^{n-1}] \left(\frac{z}{G(z)}\right)^n = \frac 1n [z^{n-1}](1 + z)^{nt} = \frac 1n \binom{nt}{n-1}$$</div></p>
<p><span class="markdown-them-math-inline">$n &gt; 0$</span> 时应用吸收恒等式得到</p>
<p><div class="markdown-them-math-block">$$\frac 1n \binom{nt}{n-1} = \frac{1}{nt + 1}\binom{nt + 1}{n}$$</div></p>
<p><span class="markdown-them-math-inline">$n = 0$</span> 时显然成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因此得到了如此构造的 <span class="markdown-them-math-inline">$\mathcal{B}_t(z)$</span> 满足定义式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>有时我们会发现这个形式并不广泛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就启发我们构造一些更广泛的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.1.2 }$</span></p>
<p>广义二项级数满足</p>
<p><div class="markdown-them-math-block">$$\mathcal{B}_t(z)^r = \sum_{n \ge 0} \binom{tn + r}{n} \frac{r}{tn + r}z^n$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>令 <span class="markdown-them-math-inline">$H(z) = (z + 1)^r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$[z^n]\mathcal{B}_t(z)^r = [z^n]H(F(z)) = \frac{1}{n} [z^{n-1}] H'(z) \left(\frac{z}{G(z)}\right)^n = \frac{r}{n} [z^{n-1}](1 + z)^{nt + r - 1} = \frac{r}{n} \binom{nt + r - 1}{n - 1}$$</div></p>
<p>如上地讨论可以得到 <span class="markdown-them-math-inline">$\mathcal{B}_t(z)^r$</span> 的系数满足定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后我们需要证明一个虽然有用但是证明十分麻烦的定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.1.3 }$</span></p>
<p>广义二项级数满足</p>
<p><div class="markdown-them-math-block">$$\frac{\mathcal{B}_t(z)^r}{ 1 - t + t\mathcal{B}_t(z)^{-1}} = \sum_{n \ge 0} \binom{tn + r}{n}z^n$$</div></p>
</blockquote>
<p>令 <span class="markdown-them-math-inline">$H(z) = \dfrac{(1 + z)^r}{1 - t + t(1 + z)^{-1}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; [z^n]\frac{\mathcal{B}_t(z)^r}{ 1 - t + t\mathcal{B}_t(z)^{-1}}
\\ = \ &amp; [z^n] H(F(z))
\\ = \ &amp; \frac 1n [z^{n-1}] H'(z) \left(\frac{z}{G(z)}\right)^n
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt} \left(\frac{(1 + z)^r}{1 - t + t(1 + z)^{-1}}\right)'
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt} \left(\frac{r(1 + z)^{r-1}\left(1 - t + t(1 + z)^{-1}\right) - (1 + z)^r\left(1 - t + t(1 + z)^{-1}\right)'}{\left(1 - t + t(1 + z)^{-1}\right)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt} \left(\frac{r(1 + z)^{r-1}\left(1 - t + t(1 + z)^{-1}\right) + t(1 + z)^r(1 + z)^{-2}}{\left(1 - t + t(1 + z)^{-1}\right)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt + r} \left(\frac{r(1 + z)^{-1}\left(1 - t + t(1 + z)^{-1}\right) + t(1 + z)^{-2}}{\left(1 - t + t(1 + z)^{-1}\right)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt + r} \left(\frac{r(1 + z)^{-1}}{\left(1 - t + t(1 + z)^{-1}\right)} + \frac{t(1 + z)^{-2}}{\left(1 - t + t(1 + z)^{-1}\right)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt + r} \left(\frac{r}{(1 - t)(1 + z) + t} + \frac{t}{\left((1 - t)(1 + z) + t\right)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] (1 + z)^{nt + r} \left(\frac{r}{1 - (t - 1)z} + \frac{t}{\left(1 - (t - 1)z\right)^2}\right)
\\ = \ &amp; \frac 1n \sum_{i=0}^{n-1} \binom{nt + r}{i} \left(r(t - 1)^{n - 1 - i} + t(n - i)(t - 1)^{n - 1 - i}\right) 
\\ = \ &amp; \frac 1n \left((nt + r)\sum_{i=0}^{n-1} \binom{nt + r}{i} (t - 1)^{n - 1 - i} - t\sum_{i=0}^{n-1} \binom{nt + r}{i} i(t - 1)^{n - 1 - i}\right) 
\\ = \ &amp; \frac 1n [z^{n-1}]\left((nt + r)\frac{(1 + z)^{nt + r}}{1 - (t - 1)z} - t\frac{z\left((1 + z)^{nt + r}\right)'}{1 - (t-1)z}\right)
\\ = \ &amp; \frac 1n [z^{n-1}]\frac{(nt + r)(1 + z)^{nt + r} - tz(nt + r)(1 + z)^{nt+r-1}}{1 - (t - 1)z} 
\\ = \ &amp; \frac 1n [z^{n-1}]\frac{(nt + r)(1 + z)^{nt + r - 1} (1 - z - tz)}{1 - (t - 1)z} 
\\ = \ &amp; \frac 1n [z^{n-1}](nt + r)(1 + z)^{nt + r - 1}
\\ = \ &amp; \frac {nt + r}n \binom{nt + r - 1}{n-1}
\\ = \ &amp; \binom{nt + r }{n}
\end{aligned}$$</div></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><s>发生了严重的中间表示膨胀</s> 神乎其技</p>
<p>中间由生成函数形式转化为系数形式再转化为生成函数形式的手法来自 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/EntropyIncreaser/ying-ye-ri-zhi-202059-post">营业日志 2020.5.9, EntropyIncreaser</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个手法常用在被提取级数形式简单但无法进一步化简的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
感觉直接在生成函数上推导的方式是可以试着<s>从结果倒着</s>推导出来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但未成功<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>关于这些定理的组合意义证明可以参考<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>具体数学<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span><span class="markdown-them-math-inline">$7.5$</span> 章例 <span class="markdown-them-math-inline">$5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这里提一句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathcal{B}_2(z)$</span> 的系数又称卡特兰数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\text{Bonus :}$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>具体数学 习题 <span class="markdown-them-math-inline">$5.19$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>如何证明 <span class="markdown-them-math-inline">$\mathcal{B}_t(z)\times \mathcal{B}_{1 - t}(-z) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></p>
<h3 id="广义指数级数">广义指数级数</h3>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定义 附 3.2.1 }\text{(广义指数级数)}$</span></p>
<p>定义广义指数级数为</p>
<p><div class="markdown-them-math-block">$$\mathcal{E}_t(z) = \sum_{n \ge 0} {(nt + 1)}^{n-1}\frac{z^n}{n!}$$</div></p>
</blockquote>
<p>下面仍然是三个和上面类似的定理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.2.1 }$</span></p>
<p>广义指数级数满足</p>
<p><div class="markdown-them-math-block">$$\mathcal{E}_t(z)^{-t} \ln \mathcal{E}_t(z) = z$$</div></p>
</blockquote>
<p>令 <span class="markdown-them-math-inline">$F(z) = \ln \mathcal{E}_t(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则有</p>
<p><div class="markdown-them-math-block">$$\frac{F(z)}{e^{tF(z)}} = z$$</div></p>
<p>我们现在需要验证满足上面的 <span class="markdown-them-math-inline">$F(z)$</span> 对应的 <span class="markdown-them-math-inline">$e^{F(z)}$</span> 的系数是否即为 <span class="markdown-them-math-inline">$\mathcal{E}_t(z)$</span> 的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由上式可以发现 <span class="markdown-them-math-inline">$F^{\langle -1\rangle}(z) = \dfrac{z}{e^{tz}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$[z^n] e^{F(z)} = \frac 1n [z^{n-1}] \left(e^ z\right)'\left(\frac{z}{F^{\langle -1\rangle}(z)}\right)^n = \frac 1n [z^{n-1}] e ^{(nt + 1)z} = \frac{(nt + 1)^{n-1}}{n!} $$</div></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.2.2 }$</span></p>
<p>广义指数级数满足</p>
<p><div class="markdown-them-math-block">$$\mathcal{E}_t(z)^r = \sum_{n \ge 0} r {(tn + r)}^{n-1}\frac{z^n}{n!}$$</div></p>
</blockquote>
<p>我们需要提取 <span class="markdown-them-math-inline">$e^{rF(z)}$</span> 的系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于我们已经得到了 <span class="markdown-them-math-inline">$F^{\langle -1\rangle}(z)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$[z^n] e^{rF(z)} = \frac 1n [z^{n-1}] (e^{rz})' (e^{tz})^n = \frac{r}{n} [z^{n-1}] e^{(nt + r)z} = \frac{r(nt + r)^{n-1}}{n!} $$</div></p>
<p>具体数学 p.364 写到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个定理可以通过将 <span class="markdown-them-math-inline">$\mathcal{E}_t(z)^r$</span> 视作 <span class="markdown-them-math-inline">$\mathcal{B}_t(z)$</span> 的极限情况来证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为不难证明</p>
<p><div class="markdown-them-math-block">$$\mathcal{E}_t(z)^r = \lim_{x\to \infty}B_{xt}(z/x)^{xr}$$</div></p>
<p>这个证明不难<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先不考虑 <span class="markdown-them-math-inline">$r$</span> 次幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写出</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \ \lim_{x\to \infty}B_{xt}(z/x)^{x}
\\ = \ &amp; \lim_{x \to \infty} \sum_{n \ge 0} \binom{xtn + x}{n} \frac{x}{xtn + x} \frac{z^n}{x^n}
\\ = \ &amp; \sum_{n \ge 0} \lim_{x \to \infty} \binom{x(nt + 1)}{n} \frac{z^n}{x^n(nt + 1)}
\\ = \ &amp; \sum_{n \ge 0} \left( \lim_{x \to \infty} (x(nt+1))^{\underline n} \frac{1}{x^n (nt + 1)} \right) \frac{z^n}{n!}
\\ = \ &amp; \sum_{n \ge 0} \left( \lim_{x \to \infty} (nt + 1 - 1/x)(nt + 1 - 2/x)\cdots(nt + 1 - (n - 1) / x)   \right) \frac{z^n}{n!}
\\ = \ &amp; \sum_{n \ge 0} (nt + 1)^{n-1} \frac{z^n}{n!}
\\ = \ &amp; \mathcal{E}_t(z)
\end{aligned}$$</div></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\textbf{定理 附 3.2.3 }$</span></p>
<p>广义指数级数满足</p>
<p><div class="markdown-them-math-block">$$\frac{\mathcal{E}_t(z)^r}{1 - zt\mathcal{E}_t(z)^t} = \sum_{n\ge 0} (tn + r)^n \frac{z^n}{n!}$$</div></p>
</blockquote>
<p>由定理 附 <span class="markdown-them-math-inline">$3.2.1$</span> 可以得到 <span class="markdown-them-math-inline">$F(z) = z\mathcal{E}_t(z)^t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是我们仍然可以直接应用定理 <span class="markdown-them-math-inline">$1.4.2$</span> 得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; [z^n]\frac{\mathcal{E}_t(z)^r}{1 - zt\mathcal{E}_t(z)^t}
\\ = \ &amp; \frac 1n [z^{n-1}] \left(\frac{e^{rz}}{1 - tz}\right)' (e^{tz})^n
\\ = \ &amp; \frac 1n [z^{n-1}] (e^{tz})^n \left(\frac{re^{rz}(1 - tz) + te^{rz}}{(1 - tz)^2}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] e^{(nt + r)z} \left(\frac{r}{(1 - tz)} + \frac{t}{(1 - tz)^2}\right)
\\ = \ &amp; \frac 1n \left(\sum_{i=0}^{n-1} \frac{(nt + r)^i}{i!} \times rt^{n - 1 - i} + \sum_{i=0}^{n-1} \frac{(nt + r)^i}{i!} \times (n - i)t^{n - i}\right)
\\ = \ &amp; \frac 1n \left(\sum_{i=0}^{n-1} \frac{(nt + r)^i}{i!} \times t^{n - 1 - i} \times(nt + r - it) \right)
\\ = \ &amp; \frac 1n [z^{n-1}] \left((nt + r) \frac{e^{(nt + r)z}}{1 - tz} - t\frac{z(e^{(nt + r)z})'}{1 - tz}\right)
\\ = \ &amp; \frac 1n [z^{n-1}] \frac{(nt + r)e^{(nt + r)z} - tz(e^{(nt + r)z})'}{1 - tz}
\\ = \ &amp; \frac 1n [z^{n-1}] \frac{(nt + r)e^{(nt + r)z} - tz(nt + r)e^{(nt + r)z}}{1 - tz}
\\ = \ &amp; \frac 1n [z^{n-1}] \frac{(nt + r)e^{(nt + r)z} (1 - tz)}{1 - tz}
\\ = \ &amp; \frac 1n [z^{n-1}] (nt + r)e^{(nt + r)z}
\\ = \ &amp; \frac {nt + r}{n} \frac{(nt + r)^{n-1}}{(n-1)!}
\\ = \ &amp; \frac{(nt + r)^n}{n!}
\end{aligned}$$</div></p>
<p>证毕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/08/05/%E7%AD%9B%E6%B3%95%E7%9B%B8%E5%85%B3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">
        
          筛法相关
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      Copyright &copy; 2024 joke3579<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="/mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->

  </div>
</body>
</html>