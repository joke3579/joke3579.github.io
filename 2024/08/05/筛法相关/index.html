<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>筛法相关 | joke3579</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="杜教筛，贝尔级数，Min_25 筛">
  
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">归档</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="/" id="logo">Dr. Zhow</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-筛法相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/05/%E7%AD%9B%E6%B3%95%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2024-08-05T11:42:35.000Z" itemprop="datePublished">2024-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      筛法相关
    </h1>
  

      </header>
    
    
<div id="article-toc">
    <h2 class="widget-title">目录</h2>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%9C%E6%95%99%E7%AD%9B"><span class="toc-number">1.</span> <span class="toc-text">杜教筛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%9D%E5%B0%94%E7%BA%A7%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">贝尔级数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">2.2.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#min_25-%E7%AD%9B"><span class="toc-number">3.</span> <span class="toc-text">Min_25 筛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0%E9%83%A8%E5%88%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">质数部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%AD%94%E6%A1%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">统计答案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">3.2.</span> <span class="toc-text">例题</span></a></li></ol></li></ol>
</div>

    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="杜教筛">杜教筛</h1>
<h2 id="描述">描述</h2>
<p>首先这玩意的前置知识是 Dirichlet 卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记这个复合为 <span class="markdown-them-math-inline">$*$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>正常的点值乘法为 <span class="markdown-them-math-inline">$\times$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其实推导式子是不用莫反的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>假设我们有一个积性函数 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义它的前缀和函数为 <span class="markdown-them-math-inline">$S(f, n) = \sum_{i=1}^n f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>现在需要解决的是快速算出 <span class="markdown-them-math-inline">$S(f, n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由 duls 总结的杜教筛对一部分具有特殊性质的 <span class="markdown-them-math-inline">$f$</span> 提供了一种 <span class="markdown-them-math-inline">$O(n^{2/3})$</span> 时间复杂度的解决方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>具体地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们构造 <span class="markdown-them-math-inline">$g,h\text{ s.t. } h = f * g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设我们容易对给定的多个 <span class="markdown-them-math-inline">$k \le n \text{ s.t. } \exists x, k = \left\lfloor \frac nx \right\rfloor$</span> 求得 <span class="markdown-them-math-inline">$S(g, k)$</span> 和 <span class="markdown-them-math-inline">$S(h, k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以应用杜教筛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>杜教筛的推导如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
S(h, n) &amp; = \sum_{x=1}^n h(x)
\\ &amp; = \sum_{x = 1}^n \sum_{d|x} g(d) f(\frac xd)
\\ &amp; = \sum_{d = 1}^n g(d) \sum_{x = 1}^{\left\lfloor \frac n d \right\rfloor} f(x)
\\ &amp; = \sum_{d = 1}^n g(d) S(f, \left\lfloor \frac n d \right\rfloor)
\\ &amp; = g(1) S(f, n) + \sum_{d = 2}^n g(d) S(f, \left\lfloor \frac n d \right\rfloor)
\\ g(1) S(f, n) &amp; = S(h, n) - \sum_{d = 2}^n g(d) S(f, \left\lfloor \frac n d \right\rfloor)
\\ S(f, n) &amp; = \frac{1}{g(1)} \left( S(h, n) - \sum_{d = 2}^n g(d) S(f, \left\lfloor \frac n d \right\rfloor) \right)
\end{aligned}$$</div></p>
<p>所以就可以按照上面的方式递归了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一般 <span class="markdown-them-math-inline">$g(1)$</span> 是 <span class="markdown-them-math-inline">$1$</span> 所以可以忽略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>那复杂度是多少呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>应用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/paperessay221204.html#-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">分析 <span class="markdown-them-math-inline">$Min25$</span> 筛时用到的渐进方式</a>可以得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum_{i=1}^{\sqrt n} O(\sqrt i) + \sum_{i=1}^{\sqrt n} O(\sqrt \frac ni) 
\\ = \ &amp; O\left(\int_{1}^{\sqrt n} x^{\frac 12} \text dx\right) + O\left(\int_{1}^{\sqrt n} (\frac n x)^{\frac 12} \text dx\right)
\\ = \ &amp; O\left(n^{3/4} \right) + O\left(n^{3/4} \right)
\end{aligned}$$</div></p>
<p>因此不预处理的复杂度是 <span class="markdown-them-math-inline">$O\left(n^{3/4} \right)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里默认记忆化了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>欸你刚才不是说 <span class="markdown-them-math-inline">$2/3$</span> 吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>咋变慢了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><br>
别着急<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>现在考虑预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们预处理前 <span class="markdown-them-math-inline">$B$</span> 个位置的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且有 <span class="markdown-them-math-inline">$B \ge \sqrt n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度就变成了</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
\sum_{i=B}^{\sqrt n} O(\sqrt \frac ni) = O\left(\frac{n}{\sqrt B}\right)
\end{aligned}$$</div></p>
<p>取 <span class="markdown-them-math-inline">$B = n^{2/3}$</span> 得到总时间复杂度 <span class="markdown-them-math-inline">$O(n^{2/3})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>总结一下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>杜教筛是一类特殊的递归方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们首先选取两个易求前缀和的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随后将所求函数 <span class="markdown-them-math-inline">$f$</span> 的前 <span class="markdown-them-math-inline">$n^{2/3}$</span> 个点值求出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>做前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后记忆化递归<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在过程中模拟如上的式子就能得到最终答案了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
还发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于杜教筛的记忆化性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其可以在一次求解中得到 <span class="markdown-them-math-inline">$n$</span> 对应 <span class="markdown-them-math-inline">$O(\sqrt n)$</span> 个数论分块点值处的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此其时间复杂度应当均摊分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于数论分块中时总复杂度没有退化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
重复式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>构造 <span class="markdown-them-math-inline">$g,h\text{ s.t. } h = f * g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$S(f, n) = \frac{1}{g(1)} \left( S(h, n) - \sum_{d = 2}^n g(d) S(f, \left\lfloor \frac n d \right\rfloor) \right)$$</div></p>
<p>给出几个常见的数论函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>欧拉函数 <span class="markdown-them-math-inline">$\varphi(n) = \sum_{(d,n) =1} 1$</span></li>
<li>莫比乌斯函数 <span class="markdown-them-math-inline">$\mu(n)$</span></li>
<li>恒等函数 <span class="markdown-them-math-inline">$\text I(n) = 1$</span></li>
<li>元函数 <span class="markdown-them-math-inline">$e(n) = [n = 1]$</span></li>
<li>单位函数 <span class="markdown-them-math-inline">$\text{id} (n) = n$</span></li>
<li>约数个数函数 <span class="markdown-them-math-inline">$\text{d} (n) = \sum_{d | n} 1$</span></li>
<li>题面里给的函数 <span class="markdown-them-math-inline">$f(n) = \small{我怎么知道}$</span></li>
</ul>
<p>这里记 <span class="markdown-them-math-inline">$k$</span> 个数论函数 <span class="markdown-them-math-inline">$f$</span> 卷起来的函数为 <span class="markdown-them-math-inline">$f_k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>给出几个常见的构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><span class="markdown-them-math-inline">$\mu * \text I = e \ \to \ f = (f * \text I) * \mu$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>该变换即莫比乌斯反演<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$\varphi * \text I = \text {id}\ \to \ \text{id} * \mu = \varphi$</span></li>
<li><span class="markdown-them-math-inline">$\text{id} * \text{id} = \text{id} \times \text d$</span></li>
</ul>
<p>结合例题来理解吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="例题">例题</h2>
<p>首先是板子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4213"><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>模板<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>杜教筛</a></p>
<p>给定正整数 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$S(\varphi, n)$</span> 与 <span class="markdown-them-math-inline">$S(\mu, n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$n \le 10^{11}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>照上式模拟即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体看代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>code</summary>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,b) for ( register int (i) = (a); (i) &lt;= (b); ++(i) )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pre(i,a,b) for ( register int (i) = (a); (i) &gt;= (b); --(i) )</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">5e6</span> + <span class="hljs-number">10</span>, L = <span class="hljs-number">5e6</span>;
<span class="hljs-keyword">int</span> T, n;

<span class="hljs-keyword">int</span> prime[N], cnt, phi[N], mu[N];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span> </span>&#123;
		phi[<span class="hljs-number">1</span>] = mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,L) &#123;
				<span class="hljs-keyword">if</span> (phi[i] == <span class="hljs-number">0</span>) prime[++cnt] = i, phi[i] = i - <span class="hljs-number">1</span>, mu[i] = - <span class="hljs-number">1</span>;
				<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;
						<span class="hljs-keyword">int</span> tmp = i * prime[j];
						<span class="hljs-keyword">if</span> (tmp &gt; L) <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;
								phi[tmp] = prime[j] * phi[i]; mu[tmp] = <span class="hljs-number">0</span>;
								<span class="hljs-keyword">break</span>;
						&#125; <span class="hljs-keyword">else</span> 
								phi[tmp] = phi[prime[j]] * phi[i]; mu[tmp] = -mu[i];
				&#125;
		&#125; 
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,L) phi[i] = phi[i<span class="hljs-number">-1</span>] + phi[i], mu[i] = mu[i<span class="hljs-number">-1</span>] + mu[i];
&#125;

<span class="hljs-keyword">int</span> _phi[N], _mu[N];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPhi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (x &lt;= L) <span class="hljs-keyword">return</span> phi[x];
	<span class="hljs-keyword">if</span> (~_phi[n / x]) <span class="hljs-keyword">return</span> _phi[n / x];
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">1ll</span> * x * (x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, r; l &lt;= x; l = r+<span class="hljs-number">1</span>) &#123;
		r = x / ( x / l );
		ret -= (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">getPhi</span>(x / l);
	&#125; 
	<span class="hljs-keyword">return</span> _phi[n / x] = ret;
&#125;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (x &lt;= L) <span class="hljs-keyword">return</span> mu[x];
	<span class="hljs-keyword">if</span> (~_mu[n / x]) <span class="hljs-keyword">return</span> _mu[n / x];
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, r; l &lt;= x; l = r + <span class="hljs-number">1</span>) &#123;
		r = x / ( x / l );
		ret -= (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">getMu</span>(x / l);
	&#125; 
	<span class="hljs-keyword">return</span> _mu[n / x] = ret;
&#125;

<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">sieve</span>(); cin &gt;&gt; T;
	<span class="hljs-keyword">while</span> (T--) &#123;
		cin &gt;&gt; n;
		<span class="hljs-built_in">memset</span>(_phi, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> _phi);
		<span class="hljs-built_in">memset</span>(_mu, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> _mu);
		cout &lt;&lt; <span class="hljs-built_in">getPhi</span>(n) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">getMu</span>(n) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
	&#125; 
&#125;
</code></pre></div>
</details>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6491">简单的最大公约数</a></p>
<p>给定 <span class="markdown-them-math-inline">$n,k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求</p>
<p><div class="markdown-them-math-block">$$\sum^k_{a_1=1}\sum^k_{a_2=1}\sum^k_{a_3=1}\dots\sum^k_{a_n=1}\gcd(a_1,a_2,a_3,\dots,a_n)\pmod{ 1000000007}$$</div></p>
<p><span class="markdown-them-math-inline">$n,k \le 10^{11}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>直接化式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum^k_{a_1=1}\sum^k_{a_2=1}\sum^k_{a_3=1}\dots\sum^k_{a_n=1}\gcd(a_1,a_2,a_3,\dots,a_n)
\\ = &amp; \  \sum^k_{a_1=1}\sum^k_{a_2=1}\sum^k_{a_3=1}\dots\sum^k_{a_n=1}\sum_{x=1}x[\gcd(a_1,a_2,a_3,\dots,a_n) = x]
\\ = &amp; \  \sum_{x=1}x\sum^{\lfloor\frac kx\rfloor}_{a_1=1}\sum^{\lfloor\frac kx\rfloor}_{a_2=1}\sum^{\lfloor\frac kx\rfloor}_{a_3=1}\dots\sum^{\lfloor\frac kx\rfloor}_{a_n=1}[\gcd(a_1,a_2,a_3,\dots,a_n) = 1]
\\ = &amp; \  \sum_{x=1}x\sum^{\lfloor\frac kx\rfloor}_{a_1=1}\sum^{\lfloor\frac kx\rfloor}_{a_2=1}\sum^{\lfloor\frac kx\rfloor}_{a_3=1}\dots\sum^{\lfloor\frac kx\rfloor}_{a_n=1}[\gcd(a_1,a_2,a_3,\dots,a_n) = 1]
\\ = &amp; \  \sum_{x=1}x\sum^{\lfloor\frac kx\rfloor}_{a_1=1}\sum^{\lfloor\frac kx\rfloor}_{a_2=1}\sum^{\lfloor\frac kx\rfloor}_{a_3=1}\dots\sum^{\lfloor\frac kx\rfloor}_{a_n=1}\sum_{d|\gcd(a_1,a_2,a_3,\dots,a_n)}\mu(d)
\\ = &amp; \  \sum_{x=1}x\sum_{d=1}\mu(d)\sum^{\lfloor\frac k{xd}\rfloor}_{a_1=1}\sum^{\lfloor\frac k{xd}\rfloor}_{a_2=1}\sum^{\lfloor\frac k{xd}\rfloor}_{a_3=1}\dots\sum^{\lfloor\frac k{xd}\rfloor}_{a_n=1}
\\ = &amp; \  \sum_{T=1}\sum_{d|T}\frac Td\mu(d)\sum^{\lfloor\frac k{T}\rfloor}_{a_1=1}\sum^{\lfloor\frac k{T}\rfloor}_{a_2=1}\sum^{\lfloor\frac k{T}\rfloor}_{a_3=1}\dots\sum^{\lfloor\frac k{T}\rfloor}_{a_n=1}
\\ = &amp; \  \sum_{T=1}\sum_{d|T}\frac Td\mu(d)\left\lfloor\frac kT\right\rfloor^n
\\ = &amp; \  \sum_{T=1}\left\lfloor\frac kT\right\rfloor^n\sum_{d|T}\frac Td\mu(d)
\\ = &amp; \  \sum_{T=1}\left\lfloor\frac kT\right\rfloor^n\varphi(T)
\end{aligned}$$</div></p>
<details>
<summary>一点脑子不用动的线性筛写法</summary>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; 
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(T &amp; x)</span> </span>&#123;
	x = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">false</span>; <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">or</span> ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) f = f <span class="hljs-keyword">or</span> ch == <span class="hljs-string">&#x27;-&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>(); f &amp;&amp; (x = -x); 
&#125; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... Args&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(T &amp; a, Args &amp; ... b)</span> </span>&#123; <span class="hljs-built_in">get</span>(a); <span class="hljs-built_in">get</span>(b...); &#125;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i &lt; i##_; ++ i)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i &gt; i##_; -- i)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-keyword">int</span> n, k, ans;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (b) &#123;
		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ret = <span class="hljs-number">1ll</span> * ret * a % mod;
		a = <span class="hljs-number">1ll</span> * a * a % mod;
		b &gt;&gt;= <span class="hljs-number">1</span>;
	&#125; <span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-keyword">int</span> prime[N], cnt, phi[N];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span> </span>&#123;
	phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,k) &#123;
		<span class="hljs-keyword">if</span> (phi[i] == <span class="hljs-number">0</span>) phi[i] = i - <span class="hljs-number">1</span>, prime[++cnt] = i;
		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;
			<span class="hljs-keyword">int</span> t = i * prime[j];
			<span class="hljs-keyword">if</span> (t &gt; k) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">if</span> (i % prime[j]) phi[t] = phi[i] * phi[prime[j]];
			<span class="hljs-keyword">else</span> &#123;
				phi[t] = phi[i] * prime[j];
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
	&#125; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,k) phi[i] = (phi[i] + phi[i - <span class="hljs-number">1</span>]) % mod;
&#125;

<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">get</span>(n, k);
	<span class="hljs-built_in">sieve</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r; l &lt;= k; l = r + <span class="hljs-number">1</span>) &#123;
		r = k / (k / l);
		ans = (ans + <span class="hljs-number">1ll</span> * (phi[r] - phi[l - <span class="hljs-number">1</span>] + mod) * <span class="hljs-built_in">qp</span>(k / l, n)) % mod;
	&#125; cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;
</code></pre></div>
</details>
<details>
<summary>完全没有动脑子只是凭肌肉记忆打出来的杜</summary>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; 
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int unsigned long long</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(T &amp; x)</span> </span>&#123;
	x = <span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">false</span>; <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">or</span> ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) f = f <span class="hljs-keyword">or</span> ch == <span class="hljs-string">&#x27;-&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();
	<span class="hljs-keyword">while</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch <span class="hljs-keyword">and</span> ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>(); f &amp;&amp; (x = -x); 
&#125; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ... Args&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(T &amp; a, Args &amp; ... b)</span> </span>&#123; <span class="hljs-built_in">get</span>(a); <span class="hljs-built_in">get</span>(b...); &#125;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i &lt; i##_; ++ i)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i &gt; i##_; -- i)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e7</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> n, k, ans, mx;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (b) &#123;
		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ret = ret * a;
		a = a * a;
		b &gt;&gt;= <span class="hljs-number">1</span>;
	&#125; <span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-keyword">int</span> prime[N], cnt, phi[N];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k = N - <span class="hljs-number">10</span>)</span> </span>&#123;
	phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,k) &#123;
		<span class="hljs-keyword">if</span> (phi[i] == <span class="hljs-number">0</span>) phi[i] = i - <span class="hljs-number">1</span>, prime[++cnt] = i;
		<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123;
			<span class="hljs-keyword">int</span> t = i * prime[j];
			<span class="hljs-keyword">if</span> (t &gt; k) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">if</span> (i % prime[j]) phi[t] = phi[i] * phi[prime[j]];
			<span class="hljs-keyword">else</span> &#123;
				phi[t] = phi[i] * prime[j];
				<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
	&#125; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,k) phi[i] += phi[i - <span class="hljs-number">1</span>];
&#125;

unordered_map &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cphi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt;= mx) <span class="hljs-keyword">return</span> phi[n];
	<span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(n)) <span class="hljs-keyword">return</span> mp[n];
	<span class="hljs-keyword">int</span> ret;
	<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) ret = ((n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) * n;
	<span class="hljs-keyword">else</span> ret = (n &gt;&gt; <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;
		r = n / (n / l);
		ret -= (r - l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">cphi</span>(n / l);
	&#125; <span class="hljs-keyword">return</span> mp[n] = ret;
&#125;

<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-built_in">get</span>(n, k); mx = <span class="hljs-built_in">pow</span>(k, <span class="hljs-number">2.0</span> / <span class="hljs-number">3</span>);
	<span class="hljs-built_in">sieve</span>(mx);
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r; l &lt;= k; l = r + <span class="hljs-number">1</span>) &#123;
		r = k / (k / l);
		ans += <span class="hljs-number">1ll</span> * (<span class="hljs-built_in">cphi</span>(r) - <span class="hljs-built_in">cphi</span>(l - <span class="hljs-number">1</span>)) * <span class="hljs-built_in">qp</span>(k / l, n);
	&#125; cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;
</code></pre></div>
</details>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/problem/3512">DZY Loves Math IV</a></p>
<p>给定 <span class="markdown-them-math-inline">$n,m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求</p>
<p><div class="markdown-them-math-block">$$\sum_{i=1}^n \sum_{j=1}^m \varphi(ij) \pmod{1000000007}$$</div></p>
<p><span class="markdown-them-math-inline">$n \le 10^5, m \le 10^9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>考虑 <span class="markdown-them-math-inline">$n$</span> 比较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以对每个 <span class="markdown-them-math-inline">$n$</span> 计算答案后求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>现在的问题是求解<br>
<div class="markdown-them-math-block">$$S(n, m) = \sum_{i=1}^m \varphi(in)$$</div></p>
<p>假设 <span class="markdown-them-math-inline">$n = pq$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$p$</span> 是将 <span class="markdown-them-math-inline">$n$</span> 的所有质因子拿出一个来求积的得数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们有</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
S(n, m) &amp; \ = \sum_{i=1}^m \varphi(in)
\\ &amp; \ = q\sum_{i=1}^m \varphi(ip)
\\ &amp; \ = q\sum_{i=1}^m \varphi(\frac{p}{\gcd(i, p)}) \varphi(i) \gcd(i, p)
\\ &amp; \ = q\sum_{i=1}^m \varphi(\frac{p}{\gcd(i, p)}) \varphi(i) \sum_{d|(i, p)} \varphi(d) \qquad &amp; (\varphi * \text{I} = \text{id} )
\\ &amp; \ = q\sum_{i=1}^m \varphi(i) \sum_{d|(i, p)} \varphi\left(\frac{dp}{\gcd(i, p)} \right)\qquad &amp; (\varphi 是积性的)
\\ &amp; \ = q\sum_{i=1}^m \varphi(i) \sum_{d|(i, p)} \varphi\left(\frac{p}{d} \right)
\\ &amp; \ = q\sum_{d|p} \varphi\left(\frac{p}{d} \right)\sum_{i=1}^{m / d} \varphi(id) 
\\ &amp; \ = q\sum_{d|p} \varphi\left(\frac{p}{d} \right) S(d, \left\lfloor\frac md\right\rfloor)
\end{aligned}$$</div></p>
<p>递归计算即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>边界不再赘述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>由于最终是 <span class="markdown-them-math-inline">$\left\lfloor\frac md\right\rfloor$</span> 的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以第二维的取值数是 <span class="markdown-them-math-inline">$O(n\sqrt m)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每一层要枚举的总状态数是<span class="markdown-them-math-inline">$O(\sqrt n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此这一部分的复杂度是 <span class="markdown-them-math-inline">$O(n(\sqrt n + \sqrt m))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑杜教筛的记忆化形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>边界本质上只需要进行一次杜教筛即可全部求出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此总时间复杂度为 <span class="markdown-them-math-inline">$O(n(\sqrt n + \sqrt m) + m^{2/3})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
理论复杂度能跑 <span class="markdown-them-math-inline">$10^{11}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>本机 O2 加持下跑了 1.61s<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/submission/222627">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/problem/4916">神犇和蒟蒻</a></p>
<p>给定 <span class="markdown-them-math-inline">$n,m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求</p>
<p><div class="markdown-them-math-block">$$\sum_{i=1}^n \mu(i^2) \qquad \sum_{i=1}^n \varphi(i^2)$$</div></p>
<p><span class="markdown-them-math-inline">$n \le 10^9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>没啥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>放这题就是整点水清凉一下<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\mu$</span> 那个显然答案就是 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$\varphi$</span>……哦想起来了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>放这题是因为想告诉你们 <span class="markdown-them-math-inline">$\varphi(n^k) = n^{k-1}\varphi(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>挺好用的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$f(n) = \varphi(n) \times n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$f * \text{id} = \text{id}_2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>剩下的看代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/submission/222637">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/problem/4176">Lucas的数论</a></p>
<p>给定 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求</p>
<p><div class="markdown-them-math-block">$$\sum_{i=1}^n \sum_{j=1}^n \text d(ij) \pmod{1000000007}$$</div></p>
<p><span class="markdown-them-math-inline">$n \le 10^9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>还记得 约数个数和 那题吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><br>
直接套那个式子</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp;\sum_{i=1}^n \sum_{j=1}^n \text d(ij) 
\\ = &amp; \ \sum_{i=1}^n \sum_{j=1}^n \sum_{x|i} \sum_{y|j} [gcd(x, y) = 1]
\\ = &amp; \ \sum_{i=1}^n \sum_{j=1}^n \sum_{x|i} \sum_{y|j} \sum_{d|(x, y)}\mu(d)
\\ = &amp; \ \sum_{x = 1} \sum_{y = 1} \sum_{d|(x, y)}\mu(d) \left\lfloor \frac n{x} \right\rfloor \left\lfloor \frac n{y} \right\rfloor 
\\ = &amp; \ \sum_{d = 1}\mu(d) \sum_{x = 1} \left\lfloor \frac n{xd} \right\rfloor \sum_{y = 1} \left\lfloor \frac n{yd} \right\rfloor 
\end{aligned}$$</div></p>
<p>然后对 <span class="markdown-them-math-inline">$d$</span> 进行数论分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对 <span class="markdown-them-math-inline">$\mu$</span> 采用杜教筛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对 <span class="markdown-them-math-inline">$x,y$</span> 采用二次数论分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>根据<a target="_blank" rel="noopener" href="https://www.cnblogs.com/CDOI-24374/p/16531615.html#%E6%9D%A8%E5%8D%93%E5%87%A1%E7%AC%AC%E4%B8%80%E5%B0%8F%E5%AE%9A%E7%90%86">杨卓凡第一小定理(?)</a>可知总时间复杂度为 <span class="markdown-them-math-inline">$O(n^{3/4})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://darkbzoj.cc/submission/222641">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<hr>
<p>upd: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/CDOI-24374/p/18017310">对杜教筛的巨大常数优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>非递归</a></p>
<details>
<summary>模板题实现</summary>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/147291329">Submission</a>.</p>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inline __attribute__((__gnu_inline__, __always_inline__, __artificial__)) inline</span>
<span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;; <span class="hljs-keyword">using</span> vi = vector&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-keyword">using</span> vp = vector&lt;pii&gt;; <span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>; 
<span class="hljs-keyword">using</span> ull = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>; <span class="hljs-keyword">using</span> db = <span class="hljs-keyword">double</span>; <span class="hljs-keyword">using</span> ld = <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>; <span class="hljs-keyword">using</span> lll = <span class="hljs-keyword">__int128_t</span>;
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; T1 <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125;
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; T1 <span class="hljs-title">min</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> multi int _T_; cin &gt;&gt; _T_; for (int TestNo = 1; TestNo &lt;= _T_; ++ TestNo)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> timer cerr &lt;&lt; 1. * clock() / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span>;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> iot ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> file(x) freopen(#x<span class="hljs-meta-string">&quot;.in&quot;</span>, <span class="hljs-meta-string">&quot;r&quot;</span>, stdin), freopen(#x<span class="hljs-meta-string">&quot;.out&quot;</span>, <span class="hljs-meta-string">&quot;w&quot;</span>, stdout)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i &lt; i##_; ++ i)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i &gt; i##_; -- i)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eb emplace_back</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb pop_back</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4e6</span> + <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">const</span> ll infll = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>ll;
ll n, th, mp[N], lp[N], ilp[N], lv[N], cntl;
ll phimp[N], mump[N];
<span class="hljs-keyword">int</span> T[N], cT;
db iv[N];

ll phi[N], mu[N], pri[N], cntp;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;
		phi[<span class="hljs-number">1</span>] = mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,N) &#123;
				<span class="hljs-keyword">if</span> (!phi[i]) pri[++ cntp] = i, phi[i] = i - <span class="hljs-number">1</span>, mu[i] = <span class="hljs-number">-1</span>;
				<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cntp) &#123;
						<span class="hljs-keyword">if</span> (i * pri[j] &gt; N) <span class="hljs-keyword">break</span>;
						<span class="hljs-keyword">if</span> (i % pri[j] == <span class="hljs-number">0</span>) &#123;
								phi[i * pri[j]] = phi[i] * pri[j], mu[i * pri[j]] = <span class="hljs-number">0</span>;
								<span class="hljs-keyword">break</span>;
						&#125; <span class="hljs-keyword">else</span> &#123;
								phi[i * pri[j]] = phi[i] * (pri[j] - <span class="hljs-number">1</span>), mu[i * pri[j]] = - mu[i];
						&#125;
				&#125;
		&#125;
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,N) phi[i] += phi[i - <span class="hljs-number">1</span>], mu[i] += mu[i - <span class="hljs-number">1</span>];
&#125;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Sid(n) (1ll * (n) * ((n) + 1) / 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SI(n) (n)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Se(n) (1)</span>

<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
		cin &gt;&gt; cT;
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cT) cin &gt;&gt; T[i], n = <span class="hljs-built_in">max</span>(n, T[i]);
		th = <span class="hljs-built_in">min</span>(N - <span class="hljs-number">5</span>, (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">2.</span>/<span class="hljs-number">3</span>));
		<span class="hljs-built_in">sieve</span>(th);
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n)) iv[i] = <span class="hljs-number">1.</span> / i;
		<span class="hljs-comment">// cerr &lt;&lt; (ll)(1e10) / 10000 &lt;&lt; &#x27; &#x27; &lt;&lt; iv[10000] &lt;&lt; &#x27; &#x27; &lt;&lt; (int)((ll)(1e10) * iv[10000]) &lt;&lt; endl;</span>
		<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cT) &#123;
				n = T[i];
				<span class="hljs-keyword">if</span> (n &lt;= th) &#123;
						cout &lt;&lt; phi[n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; mu[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
						<span class="hljs-keyword">continue</span>;
				&#125;
				cntl = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; n / l &gt; th; l = r + <span class="hljs-number">1</span>) &#123;
						r = n / (n / l);
						mp[lp[++ cntl] = l] = n / l;
						<span class="hljs-built_in">rep</span>(i,l,r) lv[i] = l;
				&#125;
				<span class="hljs-built_in">pre</span>(i,cntl,<span class="hljs-number">1</span>) &#123;
						ll nc = mp[lp[i]], sqnc = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(nc);
						phimp[i] = <span class="hljs-built_in">Sid</span>(nc) + <span class="hljs-number">1ll</span> * <span class="hljs-built_in">SI</span>(sqnc) * phi[sqnc];
						mump[i] = <span class="hljs-built_in">Se</span>(nc) + <span class="hljs-number">1ll</span> * <span class="hljs-built_in">SI</span>(sqnc) * mu[sqnc];
						<span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,sqnc) &#123;
								<span class="hljs-keyword">int</span> it = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(nc * iv[j] + <span class="hljs-number">1e-8</span>); <span class="hljs-comment">// 警钟敲烂&lt;span class=&quot;bd-box&quot;&gt;&lt;h-char class=&quot;bd bd-beg&quot;&gt;&lt;h-inner&gt;：&lt;/h-inner&gt;&lt;/h-char&gt;&lt;/span&gt;如果 nc mod j = 0 则需要 + eps 防丢精</span>
								phimp[i] -= <span class="hljs-number">1ll</span> * (phi[j] - phi[j - <span class="hljs-number">1</span>]) * <span class="hljs-built_in">SI</span>(it);
								mump[i] -= <span class="hljs-number">1ll</span> * (mu[j] - mu[j - <span class="hljs-number">1</span>]) * <span class="hljs-built_in">SI</span>(it);
								<span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (it &lt;= th) &#123;
										phimp[i] -= phi[it];
										mump[i] -= mu[it];
								&#125; <span class="hljs-keyword">else</span> &#123;
										phimp[i] -= phimp[lv[lp[i] * j]];
										mump[i] -= mump[lv[lp[i] * j]];
								&#125;
						&#125;
						<span class="hljs-comment">// cerr &lt;&lt; &quot;Partial answer : &quot; &lt;&lt; nc &lt;&lt; &#x27; &#x27; &lt;&lt; sqnc &lt;&lt; &#x27; &#x27; &lt;&lt; phimp[i] &lt;&lt; &#x27; &#x27; &lt;&lt; mump[i] &lt;&lt; endl;</span>
				&#125; 

				cout &lt;&lt; phimp[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; mump[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
		&#125;
&#125;
</code></pre></div>
</details>
<h1 id="贝尔级数">贝尔级数</h1>
<h2 id="描述-1">描述</h2>
<p>贝尔级数总之就是描述一个积性函数在质数幂次处的取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以用来构造杜教筛需要的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>仍然记 Dirichlet 卷积为 <span class="markdown-them-math-inline">$*$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>积性函数的数乘为 <span class="markdown-them-math-inline">$\times$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>质数集为 <span class="markdown-them-math-inline">$\mathbb P$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
记某小写字母表示的积性函数的贝尔级数为该字母大写对应的相关符号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于特殊数论函数的贝尔级数用该函数本身替代 <span class="markdown-them-math-inline">$F$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>若该函数有上下标则在该函数全体外加括号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们定义一个积性函数 <span class="markdown-them-math-inline">$f$</span> 关于质数 <span class="markdown-them-math-inline">$p$</span> 的贝尔级数 <span class="markdown-them-math-inline">$F_p(x)$</span> 按如下方式给出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$F_p(x) = \sum_{i \ge 0} f(p^i) x^i$$</div></p>
<p>然后我们就能在某个质数幂次的取值处研究积性函数了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\text{Theorem 1}$</span></p>
<p>两个数论函数相卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其贝尔级数相乘<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
令 <span class="markdown-them-math-inline">$h = f * g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$f,g$</span> 为积性函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\begin{aligned}
H_p(x) &amp; = \sum_{i \ge 0} h(p^i) x^i
\\ &amp; = \sum_{i \ge 0} \sum_{d|p^i} f(d) g(\frac {p^i}d) x^i
\\ &amp; = \sum_{i \ge 0} \sum_{j = 0}^i f(p^j) g(p^{i-j}) x^i
\\ &amp; = \sum_{i \ge 0} \sum_{j = 0}^i f(p^j)x^j g(p^{i-j}) x^{i-j}
\\ &amp; = F_p(x) \times G_p(x)
\end{aligned}$$</div></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\text{Theorem 2}$</span></p>
<p>对于完全积性函数 <span class="markdown-them-math-inline">$f$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$F_p(x) = \frac 1 {1-f(p)x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$F_p(x) = \sum_{i \ge 0} f(p^i) x^i = \sum_{i \ge 0} \left(f(p) x\right)^i = \frac 1 {1-f(p)x}$$</div></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\text{Theorem 3}$</span></p>
<p>对于积性函数 <span class="markdown-them-math-inline">$f,g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\forall p \in \mathbb P,\ F_p(x) = G_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则 <span class="markdown-them-math-inline">$f = g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
令 <span class="markdown-them-math-inline">$n = \prod p_i ^{c_i}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有<br>
<div class="markdown-them-math-block">$$f(n) = \prod f(p_i^{c_i}) = \prod [x^{c_i}] F_{p_i}(x) = \prod [x^{c_i}] G_{p_i}(x) = g(n)$$</div></p>
<blockquote>
<p><span class="markdown-them-math-inline">$\text{Theorem 5}$</span></p>
<p>对于积性函数 <span class="markdown-them-math-inline">$f$</span> 和<strong>数论函数</strong> <span class="markdown-them-math-inline">$g$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>若 <span class="markdown-them-math-inline">$\forall p,n \ge 1, \ f(p^{n+1}) = f(p) f(p^n) - g(p) f(p^{n-1})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则</p>
<p><div class="markdown-them-math-block">$$F_p(x) = \frac{1}{1 - f(p)x + g(p)x^2}$$</div></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$f(p^{n+1})x^n = f(p) f(p^n)^n - g(p) f(p^{n-1})^n$</span></p>
<p>两边对 <span class="markdown-them-math-inline">$n &gt; 0$</span> 求和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<br>
<div class="markdown-them-math-block">$$\frac 1x \left(F_p(x) - f(1)\right) - f(p) = f(p) F_p(x) - xg(p) F_p(x) $$</div></p>
<p>整理可以得到<br>
<div class="markdown-them-math-block">$$F_p(x) = \frac{1}{1 - f(p)x + g(p)x^2}$$</div></p>
<p>一些贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li><span class="markdown-them-math-inline">$e$</span><br>
<span class="markdown-them-math-inline">$e_p(x) = \sum_{i=0} [p^i=1] x^i = 1$</span></li>
<li><span class="markdown-them-math-inline">$\text I$</span><br>
<span class="markdown-them-math-inline">$\text I_p(x) = \sum_{i=0} x^i = \frac 1 {1-x}$</span></li>
<li><span class="markdown-them-math-inline">$\text{id}_ k$</span><br>
<span class="markdown-them-math-inline">$(\text{id}_ k)_p(x) = \sum_{i=0} p^{ki}x^i = \frac 1 {1 - p^k x}$</span></li>
<li><span class="markdown-them-math-inline">$\mu = \text I^{-1}$</span><br>
<span class="markdown-them-math-inline">$\mu_p(x) = 1-x$</span></li>
<li><span class="markdown-them-math-inline">$\mu^2$</span><br>
<span class="markdown-them-math-inline">$(\mu^2)_p(x) = 1+x$</span></li>
<li><span class="markdown-them-math-inline">$\varphi = \text{id} * \mu$</span><br>
<span class="markdown-them-math-inline">$\varphi_p(x) = \frac 1 {1 - p x} \times (1-x) = \frac {1-x} {1 - p x}$</span></li>
<li><span class="markdown-them-math-inline">$\text d = \text I * \text I$</span><br>
<span class="markdown-them-math-inline">$\text d_p(x) = \frac 1 {(1-x)^2}$</span></li>
<li><span class="markdown-them-math-inline">$\sigma_k = \text I * \text{id}_k$</span><br>
<span class="markdown-them-math-inline">$(\sigma_k)_p(x) = \frac 1 {1-x}\times \frac 1 {1 - p^k x} = \frac 1 {(1-x)(1 - p^kx)}$</span></li>
<li><span class="markdown-them-math-inline">$\lambda$</span><br>
<span class="markdown-them-math-inline">$\lambda_p(x) = \frac 1 {1+x}$</span></li>
</ol>
<p>就是这一类的东西吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>用在杜教筛里面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>首先记住上面这些贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些级数都是好求前缀和的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后把题目给你的式子写成贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随后用上面的级数乘题目的式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>化简成上面的形式之积/分母的形式简单的函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>看几个例子吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>例 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$F(n) = \sum_{d|n} \mu^2 (d) \frac nd \mu\left(\frac nd\right)$</span> 的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>容易发现这个东西是 <span class="markdown-them-math-inline">$\mu^2$</span> 和 <span class="markdown-them-math-inline">$\text{id}\times \mu$</span> 的卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>前面一个好做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是后面一个咋办呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>不难发现 <span class="markdown-them-math-inline">$(\text{id}\times \mu)_p(x) = 1 - px$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因此 <span class="markdown-them-math-inline">$F_p(x) = (1 + x)(1 - px)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意到 <span class="markdown-them-math-inline">$\text{id}_p(x) = \frac {1}{1 - px}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此构造 <span class="markdown-them-math-inline">$g = \text{id}$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>例 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$f(1) = 1, \ f(p^c) = p^c + (-1)^c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$f$</span> 为积性函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求 <span class="markdown-them-math-inline">$f$</span> 的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>先别急着用 <span class="markdown-them-math-inline">$\text{Min_25}$</span> 筛<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span></p>
<p>不难发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F_p(x) = \text{id}_p(x) + \lambda_p(x) - e_p(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是由于 <span class="markdown-them-math-inline">$c^k$</span> 会为倍数贡献 <span class="markdown-them-math-inline">$k$</span> 个 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$1$</span> 处特判即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
这样可以写出 <span class="markdown-them-math-inline">$F_p(x) = \frac 1 {1 - p x} + \frac 1 {1+x} - 1 = \frac{1 - px^2}{(1 - px)(1 + x)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>发现分母是例 <span class="markdown-them-math-inline">$1$</span> 中的贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此卷上例 <span class="markdown-them-math-inline">$1$</span> 中的函数即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们构造 <span class="markdown-them-math-inline">$g(n) = \sum_{d|n} \mu^2 (d) \frac nd \mu\left(\frac nd\right), h(n) = [n = 1] + -p \times [n = p^2]$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>说了这么多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有什么实际作用吗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><s>不知道但是挺帅的</s></p>
<h2 id="例题-1">例题</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/mobius.html">可能可以看看的前置内容</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6179">Pyh 的求和</a></p>
<p><span class="markdown-them-math-inline">$T$</span> 组数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给定 <span class="markdown-them-math-inline">$n,m$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求<br>
<div class="markdown-them-math-block">$$\sum_{i=1}^n \sum_{j=1}^m \varphi(ij) \pmod{998244353}$$</div></p>
<p><span class="markdown-them-math-inline">$1 \le T, n, m, \le 10^5$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>这题和杜教筛没啥关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑用来拆开 <span class="markdown-them-math-inline">$\varphi$</span> 的第二个式子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\varphi(ij) = \gcd(i, j) \frac{\varphi(i)\varphi(j)}{\varphi(\gcd(i,j))}$$</div></p>
<p>带入能得到</p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum_{i=1}^n \sum_{j=1}^m \varphi(ij)
\\  = &amp; \ \sum_{i=1}^n \sum_{j=1}^m \gcd(i, j) \frac{\varphi(i)\varphi(j)}{\varphi(\gcd(i,j))}
\\  = &amp; \ \sum_{x = 1} \frac{x}{\varphi(x)} \sum_{i=1}^n \sum_{j=1}^m \varphi(i)\varphi(j) [\gcd(i, j) = x]
\\  = &amp; \ \sum_{x = 1} \frac{x}{\varphi(x)} \sum_{d=1} \sum_{i=1}^{\frac{n}{xd}} \sum_{j=1}^{\frac{m}{xd}} \varphi(ixd)\varphi(jxd) 
\\  = &amp; \ \sum_{x = 1} \frac{x}{\varphi(x)} \sum_{d=1} \mu(d) \sum_{i=1}^{\left \lfloor \frac{n}{xd}\right\rfloor} \sum_{j=1}^{\left \lfloor \frac{m}{xd}\right\rfloor} \varphi(ixd)\varphi(jxd) 
\\  = &amp; \ \sum_{T = 1} \left(\sum_{d|T} \frac{d}{\varphi(d)} \mu\left(\frac Td\right)\right) \left( \sum_{i=1}^{\left \lfloor \frac{n}{T}\right\rfloor} \varphi(iT) \right) \left( \sum_{j=1}^{\left \lfloor \frac{m}{T}\right\rfloor}\varphi(jT) \right)
\end{aligned}$$</div></p>
<p>我们设 <span class="markdown-them-math-inline">$f(n) = \sum_{d|n} \frac{d}{\varphi(d)} \mu\left(\frac nd\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个东西可以枚举倍数模拟 Dirichlet 卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$O(n\log n)$</span> 的复杂度内得到 <span class="markdown-them-math-inline">$1\sim n$</span> 的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这个东西没有什么好办法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只能暴力求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是暴力铁定 T 掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>咋办呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>观察咱们能用的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>第一种是对每个 <span class="markdown-them-math-inline">$n / T$</span> 和 <span class="markdown-them-math-inline">$m / T$</span> 处理前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间挺好的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是空间铁炸<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
第二种是枚举 <span class="markdown-them-math-inline">$T$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>三部分分别预处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样空间随随便便压下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是没法数论分块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>时间炸掉<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>欸你看到这俩做法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>想到了什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><br>
对<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>阈值分治后即可解决本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1653786">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$\text{Bonus : }$</span> 你是否能写出 <span class="markdown-them-math-inline">$F_p(x)$</span> 的封闭形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$\text{Bonus2 : }$</span> 本题又名<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4240">毒瘤之神的考验</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6229">这是一道简单的数学题</a></p>
<p>给定 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求<br>
<div class="markdown-them-math-block">$$\sum_{i=1}^n \sum_{j=1}^i \frac{\text{lcm}(i, j)}{\gcd(i, j)} \pmod{998244353}$$</div><br>
<span class="markdown-them-math-inline">$n \le 10^9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>如题面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们不妨先考虑两个 <span class="markdown-them-math-inline">$\sum$</span> 上界都是 <span class="markdown-them-math-inline">$n$</span> 的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到 <span class="markdown-them-math-inline">$(ans + n) / 2$</span> 就是答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$S(n) = n(n+1) / 2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接化简<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum_{i=1}^n \sum_{j=1}^m \frac{\text{lcm}(i, j)}{\gcd(i, j)}
\\  = &amp; \ \sum_{i=1}^n \sum_{j=1}^m \frac{ij}{\gcd^2(i, j)}
\\  = &amp; \ \sum_{x=1} \frac 1 {x^2} \sum_{i=1}^n \sum_{j=1}^m ij[\gcd(i, j) = x]
\\  = &amp; \ \sum_{x=1} \sum_{d = 1} \mu(d)d^2 \sum_{i=1}^{\left \lfloor \frac{n}{xd}\right\rfloor} \sum_{j=1}^{\left \lfloor \frac{m}{xd}\right\rfloor} ij
\\  = &amp; \ \sum_{x=1} \sum_{d = 1} \mu(d)d^2 S^2\left(\left \lfloor \frac{n}{xd}\right\rfloor \right)
\\  = &amp; \ \sum_{T=1}S^2\left(\left \lfloor \frac{n}{T}\right\rfloor \right) \sum_{d | T} \mu(d)d^2 
\end{aligned}$$</div></p>
<p>然后考虑 <span class="markdown-them-math-inline">$f(n) = \sum_{d | n} \mu(d)d^2$</span> 如何求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现 <span class="markdown-them-math-inline">$f = (\mu \times \text{id}_2) * \text I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>应用贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$F_p(x) = \frac{1 - p^2x}{1 - x}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这样我们只需要乘上 <span class="markdown-them-math-inline">$\frac 1{1 - p^2x}$</span> 就能得到 <span class="markdown-them-math-inline">$\frac{1}{1 - x}$</span> 了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说 <span class="markdown-them-math-inline">$f * \text{id}_2 = \text I$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>欸好简单就构造出来了呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span><br>
我就说吧我就说吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p>
<p>于是应用杜教筛与数论分块即可解决问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$f$</span> 的计算可以采用 Dirichlet 卷积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1653810">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6686">Stupid GCD</a></p>
<p>给定 <span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>求<br>
<div class="markdown-them-math-block">$$\sum_{i=1}^n \gcd\left(\lfloor i^{1/3} \rfloor, i\right) \pmod{998244353}$$</div></p>
<p><span class="markdown-them-math-inline">$n \le 10^{30}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p><s>为啥这题不叫 problemprovidercreep 啊<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></s></p>
<p>1e30<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这你肯定不能枚举 <span class="markdown-them-math-inline">$[gcd(i, j) = x]$</span> 的套路了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果有数论巨佬用枚举 <span class="markdown-them-math-inline">$\gcd$</span> 的方法爆踩了我那受我一拜顺便教教我<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑一个 <span class="markdown-them-math-inline">$\lfloor i^{1/3} \rfloor$</span> 对应的 <span class="markdown-them-math-inline">$i$</span> 其实是很长一段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这些段只有最后一段是残的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们可以将答案表示为</p>
<p><div class="markdown-them-math-block">$$\sum_{i=1}^{\lfloor n^{1/3} \rfloor - 1} \sum_{j=i^3}^{(i+1)^3 - 1} \gcd(i, j) + \sum_{i=\lfloor n^{1/3} \rfloor^3}^n \gcd\left(\lfloor n^{1/3} \rfloor, i\right)$$</div></p>
<p>分开求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>先出一个结论吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\sum_{i=1}^n \gcd(k, i) = \sum_{d|k} \varphi(d)\left\lfloor\frac nd \right\rfloor $$</div><br>
这个简单的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不展开了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后第一部分可以直接套上去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$m = \lfloor n^{1/3} \rfloor - 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum_{i=1}^{\lfloor n^{1/3} \rfloor - 1} \sum_{j=i^3}^{(i+1)^3 - 1} \gcd(i, j) 
\\ = &amp; \ \sum_{i=1}^{m} \sum_{d|i} \varphi(d)\left( \left\lfloor\frac {(i+1)^3 - 1}d \right\rfloor - \left\lfloor\frac {i^3 - 1}d \right\rfloor \right) 
\\ = &amp; \ \sum_{d = 1} \varphi(d) \sum_{i=1}^{\left\lfloor\frac md\right\rfloor}\left( \left\lfloor\frac {(id+1)^3 - 1}d \right\rfloor - \left\lfloor\frac {id^3 - 1}d \right\rfloor \right) 
\\ = &amp; \ \sum_{d = 1} \varphi(d) \sum_{i=1}^{\left\lfloor\frac md\right\rfloor} 3di^2 + 3i + 1
\end{aligned}$$</div></p>
<p>采用两种杜教筛<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><span class="markdown-them-math-inline">$\sum \varphi, \sum i\times\varphi$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>可完成这部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>总时间复杂度为 <span class="markdown-them-math-inline">$O(n^{2/9})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后第二部分可以直接套上去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 <span class="markdown-them-math-inline">$k = \lfloor n^{1/3} \rfloor$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\sum_{i=\lfloor n^{1/3} \rfloor^3}^n \gcd\left(\lfloor n^{1/3} \rfloor, i\right) = \sum_{d|k} \varphi(d) \left( \left\lfloor\frac nd \right\rfloor- \left\lfloor\frac {\lfloor n^{1/3} \rfloor^3 - 1}d\right\rfloor \right)$$</div></p>
<p>这个可以直接朴素求解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们枚举每个 <span class="markdown-them-math-inline">$d | n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于每个 <span class="markdown-them-math-inline">$d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的质因子必定是 <span class="markdown-them-math-inline">$n$</span> 的质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此预处理 <span class="markdown-them-math-inline">$n$</span> 的质因子后枚举计算 <span class="markdown-them-math-inline">$\varphi$</span> 即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>跑得挺快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>听说预处理前 <span class="markdown-them-math-inline">$10^7$</span> 的 <span class="markdown-them-math-inline">$\varphi$</span> 后总时间复杂度就是 <span class="markdown-them-math-inline">$O(n^{2/9})$</span> 的了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>没证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1653863">Submission</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=6706">魂天 ⌈奥义⌋</a></p>
<p><span class="markdown-them-math-inline">$T$</span> 组询问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给定 <span class="markdown-them-math-inline">$n,a,b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求<br>
<div class="markdown-them-math-block">$$f(n,a,b) = \sum_{i=1}^n\sum_{j=1}^i \gcd(i^a - j^a, i^b - j^b)\times [\gcd(i,j) = 1] \pmod{1000000007}$$</div><br>
<span class="markdown-them-math-inline">$1 \le n, a, b \le 10^9$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>保证 <span class="markdown-them-math-inline">$a,b$</span> 互质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$n &gt; 10^6$</span> 的询问不会超过 <span class="markdown-them-math-inline">$10$</span> 次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>首先需要证明一个结论<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<blockquote>
<p>对于 <span class="markdown-them-math-inline">$i &lt; j, \gcd(i, j) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$\gcd(i^a - j^a, i^b - j^b) = i^{\gcd(a, b)} - j^{\gcd(a, b)}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
不妨假设 <span class="markdown-them-math-inline">$a \ge b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>令 <span class="markdown-them-math-inline">$a = kb + r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
提取 <span class="markdown-them-math-inline">$(i^b - j^b)$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有 <span class="markdown-them-math-inline">$i^a - j^a = (i^b - j^b)(i^{a-b} + i^{a - 2b}j^b + \cdots + i^{r}j^{a - b - r}) + i^rj^{a-r} - j^a$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
原式 <span class="markdown-them-math-inline">$= \gcd(i^rj^{a-r} - j^a, i^b - j^b) = \gcd(j^{a - r}(i^r - j^r), i^b - j^b)$</span><br>
先不管 <span class="markdown-them-math-inline">$i^r - j^r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们着眼于 <span class="markdown-them-math-inline">$\gcd(j^{a - r}, i^b - j^b) = \gcd(j^kb, i^b - j^b)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
仍然提取 <span class="markdown-them-math-inline">$(i^b - j^b)$</span> 项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有 <span class="markdown-them-math-inline">$j^{kb} = -(i^b - j^b)(j^{(k-1)b} + i^bj^{(k-2)b} + \cdots + a^{(k-1)b}) + a^{kb}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
因此 <span class="markdown-them-math-inline">$\gcd(j^kb, i^b - j^b) = \gcd(i^kb, i^b - j^b) = d$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$\gcd(i, j) = 1$</span> 且 <span class="markdown-them-math-inline">$d|i, d|j$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$d$</span> 必等于 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此这部分不需要在意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
原式 <span class="markdown-them-math-inline">$= \gcd(j^{a - r}(i^r - j^r), i^b - j^b) = \gcd(i^r - j^r, i^b - j^b)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
根据更相减损术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结论成立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$\begin{aligned}
&amp; \sum_{i=1}^n\sum_{j=1}^i \gcd(i^a - j^a, i^b - j^b)\times [\gcd(i,j) = 1]
\\ = &amp; \ \sum_{i=1}^n\sum_{j=1}^i (i - j)\times [\gcd(i,j) = 1]
\\ = &amp; \ \sum_{d=1}\mu(d) d \sum_{i=1}^{\left\lfloor \frac nd\right\rfloor}\sum_{j=1}^i (i - j)
\end{aligned}$$</div></p>
<p>因此可以使用杜教筛解决<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>HDU 看不了代码</summary>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-function">T1 <span class="hljs-title">min</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-function">T1 <span class="hljs-title">max</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i &lt; i##_; ++ i)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pre(i,s,t) for (register int i = (s), i##_ = (t) - 1; i &gt; i##_; -- i)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;

<span class="hljs-keyword">int</span> T, n, a, b, L = <span class="hljs-number">1e6</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S(n) (((n) * (n) * (n) - (n)) * 166666668)</span>

modint _f[N], mu[N];
<span class="hljs-keyword">int</span> prime[N], cnt;
<span class="hljs-keyword">bool</span> vis[N];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">()</span> </span>&#123;
	mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
	<span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, L) &#123;
		<span class="hljs-keyword">if</span> (!vis[i]) prime[++cnt] = i, mu[i] = mod - <span class="hljs-number">1</span>;
		<span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, cnt) &#123;
			<span class="hljs-keyword">int</span> t = i * prime[j];
			<span class="hljs-keyword">if</span> (t &gt; L) <span class="hljs-keyword">break</span>;
			vis[t] = <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; 
			mu[t] -= mu[i];
		&#125;
	&#125;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,L) _f[i] = mu[i] * i + _f[i - <span class="hljs-number">1</span>];
&#125;

modint mp[N];
<span class="hljs-keyword">int</span> stk[N], top;
<span class="hljs-function">modint <span class="hljs-title">getv</span><span class="hljs-params">(modint x)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (x &lt;= L) <span class="hljs-keyword">return</span> _f[*x];
	<span class="hljs-keyword">if</span> (mp[n / (*x)] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> mp[n / (*x)];
	modint ret = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span> (modint l = <span class="hljs-number">2</span>, r; l &lt;= x; l = r + <span class="hljs-number">1</span>) &#123;
		r = x / (x / l);
		ret -= (r + l) * (r - l + <span class="hljs-number">1</span>) * <span class="hljs-number">500000004</span> * <span class="hljs-built_in">getv</span>(x / l);
	&#125; stk[++ top] = n / (*x);
	<span class="hljs-keyword">return</span> mp[n / (*x)] = ret;
&#125;

<span class="hljs-function">modint <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,top) mp[stk[i]] = <span class="hljs-number">-1</span>;
	top = <span class="hljs-number">0</span>;
	modint ans = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (modint l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;
		r = n / (n / l);
		ans += <span class="hljs-built_in">S</span>(n / l) * (<span class="hljs-built_in">getv</span>(r) - <span class="hljs-built_in">getv</span>(l - <span class="hljs-number">1</span>));
	&#125; <span class="hljs-keyword">return</span> ans;
&#125;

<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
	cin &gt;&gt; T;
	<span class="hljs-built_in">sieve</span>(); <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">100000</span>) mp[i] = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">while</span> (T --) &#123;
		cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; 
		cout &lt;&lt; <span class="hljs-built_in">f</span>(n, a, b) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
	&#125; 
&#125;
</code></pre></div>
</details>
<h1 id="min_25-筛">Min_25 筛</h1>
<h2 id="描述-2">描述</h2>
<p>一些定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><span class="markdown-them-math-inline">$n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>前缀和上界</li>
<li><span class="markdown-them-math-inline">$p_i$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>第 <span class="markdown-them-math-inline">$i$</span> 个质数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>定义 <span class="markdown-them-math-inline">$p_0  = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li><span class="markdown-them-math-inline">$p_{\max}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$&lt; \sqrt n$</span> 的最大质数</li>
<li><span class="markdown-them-math-inline">$\text{mindiv}(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$n$</span> 的最小质因子</li>
<li><span class="markdown-them-math-inline">$\mathbb{P}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>质数集合</li>
</ul>
<p>如无特殊注明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以下使用的 <span class="markdown-them-math-inline">$p$</span> 都属于 <span class="markdown-them-math-inline">$\mathbb{P}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>是更快且泛用性更广的筛子<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>相较于杜教筛而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它的复杂度在 <span class="markdown-them-math-inline">$\le 10^{13}$</span> 范围内被证明是常数很小的 <span class="markdown-them-math-inline">$O\left(\dfrac{n^{3/4}}{\log n}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在实际应用中跑得比 <span class="markdown-them-math-inline">$O(n ^ {\frac 23})$</span> 都快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体复杂度的证明可以看zzt的2018集训队论文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/paperessay221204.html">这里是我的阅读随笔</a><br>
他<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>指Min_25<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>解决的是这么一类积性函数 <span class="markdown-them-math-inline">$f$</span> 的前缀和问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>积性</li>
<li>在 <span class="markdown-them-math-inline">$p^k$</span> 处取值为一个关于 <span class="markdown-them-math-inline">$p$</span> 的多项式</li>
<li><span class="markdown-them-math-inline">$f(p^k)$</span> 可以快速算得</li>
</ol>
<p>要求 <span class="markdown-them-math-inline">$\sum\limits_{i = 1}^n f(i)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>首先进行式子的拆解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$\sum_{i = 1}^n f(i) = \sum_{\text{p为质数}}^nf(p) + \sum_{\text{k为合数}}^n f(k) + f(1)$$</div><br>
分别处理两个部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><s>你问 f(1)去哪了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>最后加1不就行了</s></p>
<h3 id="质数部分">质数部分</h3>
<p>在质数处的快速计算需要设辅助函数 <span class="markdown-them-math-inline">$g(x)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要求 <span class="markdown-them-math-inline">$g$</span> 完全积性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且在质数处的取值和 <span class="markdown-them-math-inline">$f$</span> 相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现由于原函数在质数处取值为多项式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们总可以设一个或多个 <span class="markdown-them-math-inline">$g$</span> 表示原函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 <span class="markdown-them-math-inline">$g$</span> 不止一个时分别计算贡献后相加即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
于是我们可以单独讨论一个完全积性函数 <span class="markdown-them-math-inline">$f(x)$</span> 对质数部分答案的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们设一个二元函数 <span class="markdown-them-math-inline">$g(n, k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ g(n,k) = \sum_{i \in \mathbb{P}\ \lor \ \text{mindiv}(i) &gt; p_k } ^n f(i) $$</div><br>
可以发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>质数部分的答案为 <span class="markdown-them-math-inline">$g(n,p_{\max})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即小于等于 <span class="markdown-them-math-inline">$n$</span> 的所有质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们发现这样 <span class="markdown-them-math-inline">$\lor$</span> 后面的东西没用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是带着更好求一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体见下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑通过容斥一下求出 <span class="markdown-them-math-inline">$g(n,k-1)$</span> 转移到 <span class="markdown-them-math-inline">$g(n,k)$</span> 的转移方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$k$</span> 增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相应会删除一些数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这些数就是满足最小质因子为 <span class="markdown-them-math-inline">$p_k$</span> 的合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>考虑如何表示这些被删掉的数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从共性下手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们提出一个 <span class="markdown-them-math-inline">$p_k$</span> 作为他们共有的最小质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该被删掉的数字在除掉 <span class="markdown-them-math-inline">$p_k$</span> 后不会有 <span class="markdown-them-math-inline">$\le p_{k-1}$</span> 的最小质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即满足 <span class="markdown-them-math-inline">$\text{mindiv}(i) &gt; p_{k-1}$</span> 且小于等于 <span class="markdown-them-math-inline">$\lfloor \frac n {p_k} \rfloor$</span> 的合数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这部分数字对答案的贡献可以被形式化地表示为下式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ f(p_k) \times (g(\lfloor \frac n {p_k} \rfloor , k - 1) - g(p_{k-1}, k-1)) $$</div><br>
其中减号前面为质数与合数的共同贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减号后面为质数单独的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
因此我们有状态转移方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ g(n, k) = g(n, k-1) - f(p_k) \times (g(\lfloor \frac n {p_k} \rfloor , k - 1) - g(p_{k-1}, k-1)) $$</div><br>
此处表明了 <span class="markdown-them-math-inline">$f$</span> 为完全积性函数的意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>质因子 <span class="markdown-them-math-inline">$p_k$</span> 可以被直接提出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当且仅当 <span class="markdown-them-math-inline">$f$</span> 完全积性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>考虑怎么转移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由数论分块可知我们所需的所有 <span class="markdown-them-math-inline">$\lfloor \frac n {p_k} \rfloor$</span> 状态是 <span class="markdown-them-math-inline">$O(\sqrt n)$</span> 级别的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 <span class="markdown-them-math-inline">$p_{k} \le p_{\max}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此总状态是 <span class="markdown-them-math-inline">$O(\sqrt n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此我们可以直接通过数论分块处理 <span class="markdown-them-math-inline">$i \le \sqrt{n}$</span> 的所有 <span class="markdown-them-math-inline">$g(i, 0)$</span> 与 <span class="markdown-them-math-inline">$g(\lfloor \frac n i \rfloor,  0)$</span> 取值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>随后朴素地转移状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>复杂度正确<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里不需要写二维数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要从大到小更新数值就行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
对于值的存储<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以单独开两个 <span class="markdown-them-math-inline">$\text{id}$</span> 数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分别存储 <span class="markdown-them-math-inline">$x \le \sqrt n$</span> 时 <span class="markdown-them-math-inline">$x$</span> 对应值数组下标与 <span class="markdown-them-math-inline">$x &gt; \sqrt n$</span> 时 <span class="markdown-them-math-inline">$\lfloor \frac n x \rfloor$</span> 对应值数组下标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现两个 <span class="markdown-them-math-inline">$\text{id}$</span> 数组长度都是 <span class="markdown-them-math-inline">$O(\sqrt n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样实现了快速离散化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>luogu板子的代码</summary>
<div class="highlight"><pre class="code"><code>N = <span class="hljs-built_in">sqrt</span>(n) ;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">register</span> ll pos)</span> </span>&#123; <span class="hljs-keyword">return</span> pos &lt; N ? id1[pos] : id2[n / pos]; &#125; <span class="hljs-comment">// 值的存储部分</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">S1</span><span class="hljs-params">(<span class="hljs-keyword">register</span> ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> x %= mod, x * (x + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod; &#125;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">S2</span><span class="hljs-params">(<span class="hljs-keyword">register</span> ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> x %= mod, x * (x + <span class="hljs-number">1</span>) % mod * (<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>) % mod * inv6 % mod; &#125;
<span class="hljs-comment">// 两个完全积性函数</span>

<span class="hljs-keyword">int</span> prime[<span class="hljs-number">200001</span>], cnt;
<span class="hljs-keyword">int</span> vis[<span class="hljs-number">200001</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 筛素数</span>
    <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">2</span>,N) &#123;
        <span class="hljs-keyword">if</span> (!vis[i]) prime[++cnt] = i;
        <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,cnt) &#123; <span class="hljs-keyword">int</span> tmp = i * prime[j]; <span class="hljs-keyword">if</span> (tmp &gt; N) <span class="hljs-keyword">break</span>; vis[tmp] = <span class="hljs-number">1</span>; <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; &#125;
    &#125;
&#125;

<span class="hljs-keyword">for</span> (ll l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r+<span class="hljs-number">1</span>) &#123;
    r = n / (n / l); v[++m] = n / l;
    <span class="hljs-keyword">if</span> (v[m] &lt; N) id1[v[m]] = m;
    <span class="hljs-keyword">else</span> id2[n / v[m]] = m;
    g1[m] = (<span class="hljs-built_in">S1</span>(v[m]) - <span class="hljs-number">1</span> + mod) % mod;
    g2[m] = (<span class="hljs-built_in">S2</span>(v[m]) - <span class="hljs-number">1</span> + mod) % mod;
	<span class="hljs-comment">// 首先取得 g(k,0) 的值</span>
&#125;
<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;
    <span class="hljs-built_in">rep</span>(j,<span class="hljs-number">1</span>,m) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * prime[i] * prime[i] &gt; v[j]) <span class="hljs-keyword">break</span>;
        g1[j] = (g1[j] - <span class="hljs-number">1ll</span> * prime[i] * (g1[<span class="hljs-built_in">get</span>(v[j] / prime[i])] - g1[<span class="hljs-built_in">get</span>(prime[i - <span class="hljs-number">1</span>])]) % mod + mod) % mod;
        g2[j] = (g2[j] - <span class="hljs-number">1ll</span> * <span class="hljs-built_in">sq</span>(prime[i]) * (g2[<span class="hljs-built_in">get</span>(v[j] / prime[i])] - g2[<span class="hljs-built_in">get</span>(prime[i - <span class="hljs-number">1</span>])]) % mod + mod) % mod;
		<span class="hljs-comment">// 依照上式进行dp</span>
    &#125;
&#125; 

</code></pre></div>
</details>
<h3 id="统计答案">统计答案</h3>
<p>记 <span class="markdown-them-math-inline">$g(n, p_{\max})$</span> 为 <span class="markdown-them-math-inline">$g(n)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们再设一个函数 <span class="markdown-them-math-inline">$s(n, k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里的 <span class="markdown-them-math-inline">$f$</span> 函数指代原函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不是自己构造的完全积性函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ s(n, k) = \sum_{\text{mindiv}(i) &gt; p_k}^n f(i)$$</div><br>
容易发现 <span class="markdown-them-math-inline">$s(n,0)$</span> 即为最终答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>讨论 <span class="markdown-them-math-inline">$s(n, k)$</span> 如何求得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
仍然考虑将质数与合数的贡献分离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>质数的贡献是所有大于 <span class="markdown-them-math-inline">$p_k$</span> 的质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接由 <span class="markdown-them-math-inline">$g$</span> 求得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$g(n) - g(p_k)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>合数的部分需要枚举质数的倍数求得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这也是 Min_25 筛被称为<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>拓展埃氏筛<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们枚举所有 <span class="markdown-them-math-inline">$k &gt; j$</span> 的 <span class="markdown-them-math-inline">$p_k$</span> 以及其 <span class="markdown-them-math-inline">$e$</span> 次幂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次贡献的数字为最小质因子为 <span class="markdown-them-math-inline">$p_k$</span> 且其次数为 <span class="markdown-them-math-inline">$e$</span> 的数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即除去 <span class="markdown-them-math-inline">$p_k^e$</span> 后满足 <span class="markdown-them-math-inline">$\text{mindiv}(j) &gt; p_k$</span> 的所有 <span class="markdown-them-math-inline">$j \le n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此最终统计答案时应考虑到 <span class="markdown-them-math-inline">$e$</span> 的边界为 <span class="markdown-them-math-inline">$p_k^{e+1} \le n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们在枚举次幂时总会计入 <span class="markdown-them-math-inline">$p_k$</span> 的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而一个数字显然只能被计入一次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此需要在计算时在 <span class="markdown-them-math-inline">$e&gt;1$</span> 时减去1的贡献<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>形式化地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有状态转移方程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$ s(n, k) = g(n) - g(p_k) + \sum_{p_k &gt; p_j}^{p_{\max}} \sum_{e \ge 1 \land p_k ^{e+1} \le n} f(p_k^e) \times (s(\lfloor \frac n {p_k^e} \rfloor,k) + [e \neq 1])$$</div></p>
<p>关于怎么转移……<s>暴力</s><br>
不进行记忆化的暴力转移的复杂度是对的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$10^{11}$</span> 的数据下递归到被记忆化的部分的次数是 0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<details>
<summary>第二部分luogu板子</summary>
<div class="highlight"><pre class="code"><code>
<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">S</span><span class="hljs-params">(ll x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (prime[y] &gt;= x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    ll ret = (g2[<span class="hljs-built_in">get</span>(x)] - g1[<span class="hljs-built_in">get</span>(x)] - g2[<span class="hljs-built_in">get</span>(prime[y])] + g1[<span class="hljs-built_in">get</span>(prime[y])] + (mod&lt;&lt;<span class="hljs-number">1</span>)) % mod;
    <span class="hljs-built_in">rep</span>(i,  y+<span class="hljs-number">1</span>, cnt) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * prime[i] * prime[i] &gt; x) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> ll w = prime[i]; w * prime[i] &lt;= x; w = w * prime[i]) &#123;
            ret = (ret + <span class="hljs-number">1ll</span> * <span class="hljs-built_in">F1</span>(w) * <span class="hljs-built_in">S</span>(x / w, i) % mod + <span class="hljs-built_in">F1</span>(w * prime[i])) % mod;
        &#125;
    &#125; <span class="hljs-keyword">return</span> ret;
&#125; 

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(<span class="hljs-built_in">S</span>(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>) % mod);

</code></pre></div>
</details>
<h2 id="例题-2">例题</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/3069">整点计数</a></p>
</blockquote>
<p>做法见<span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char><h-char class="bd bd-end"><h-inner>〈</h-inner></h-char></span>整点计数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>〉</h-inner></h-char></span>命题报告以及对高斯整数的若干研究<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>徐翊轩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>2019<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
写得确实挺详细的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>式子啥的都有了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>推荐阅读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joke3579/p/editorial221020.html">社论 22.10.20 二维圆周数点与高斯整数环</a><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1654713">Submission</a>.</p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6235">区间素数个数</a></p>
<p>求满足 <span class="markdown-them-math-inline">$1&lt; p \leq n$</span> 的质数 <span class="markdown-them-math-inline">$p$</span> 有多少个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$n \le 10^{11}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>应该算是 <span class="markdown-them-math-inline">$\text{Min_25}$</span> 筛的第一部分的板子了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们构造 <span class="markdown-them-math-inline">$f(n) = 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过第一部分的递推就能得到答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1654713">Submission</a>.</p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6027">质数计数 I</a></p>
<p>求满足 <span class="markdown-them-math-inline">$1&lt; p \leq n$</span> 且 <span class="markdown-them-math-inline">$p$</span> 的二进制表示最后两位为 <span class="markdown-them-math-inline">$01$</span> 的质数 <span class="markdown-them-math-inline">$p$</span> 有多少个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><span class="markdown-them-math-inline">$n \le 3\times 10^{10}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>直接做肯定不好做<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样的一个函数是完全积性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<div class="markdown-them-math-block">$$f(n) = \left\{ 
\begin{aligned}
&amp;1 ,\ &amp; n\bmod 4 = 1, \\
&amp;-1 ,\ &amp; n\bmod 4 = 3, \\
&amp;0 ,\ &amp; \text{otherwise.} \\
\end{aligned}
\right.$$</div></p>
<p>证明显然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>因此可以借助 <span class="markdown-them-math-inline">$\text{Min_25}$</span> 筛的第一部分求得 <span class="markdown-them-math-inline">$f$</span> 在质数处的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
我们发现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案是模 <span class="markdown-them-math-inline">$4$</span> 余 <span class="markdown-them-math-inline">$1$</span> 的质数数 - 模 <span class="markdown-them-math-inline">$4$</span> 余 <span class="markdown-them-math-inline">$3$</span> 的质数数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此求得质数前缀和后两个答案相加除以 <span class="markdown-them-math-inline">$2$</span> 就能得到答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
质数前缀和见例题 <span class="markdown-them-math-inline">$2$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1654864">Submission</a>.</p>
<p><a href=""></a><br>
<a href=""></a></p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6181">某个套路求和题</a></p>
<p>设</p>
<p><div class="markdown-them-math-block">$$f(n) = \prod_{d|n} \mu(d)$$</div></p>
<p>求</p>
<p><div class="markdown-them-math-block">$$\sum_{i=1}^n f(i) \pmod {998244353} $$</div></p>
<p><span class="markdown-them-math-inline">$n \le 10^{10}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</blockquote>
<p>%%% Alpha1022</p>
<p>首先 <span class="markdown-them-math-inline">$f(n)$</span> 在质数处的取值是 <span class="markdown-them-math-inline">$-1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后在有平方因子的数的取值是 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>那在其余地方呢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span><br>
假设 <span class="markdown-them-math-inline">$n$</span> 有 <span class="markdown-them-math-inline">$k &gt; 1$</span> 个质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这导出了<br>
<div class="markdown-them-math-block">$$f(n) = \prod_{i=0}^k (-1)^{i \binom{k}{i}} = (-1)^{2^{k-1} k} = 1$$</div><br>
因此我们有其余地方的值为 <span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>首先考虑 <span class="markdown-them-math-inline">$|f(n)|$</span> 是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>容易发现这个东西和 <span class="markdown-them-math-inline">$\mu^2$</span> 的表现相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>证明考虑构造贝尔级数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后只需要求出 <span class="markdown-them-math-inline">$\mu^2$</span> 的前缀和后减去两倍的质数个数就行了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面的推导来自 jijidawang<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>赞美 jijidawang<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span></p>
<p><div class="markdown-them-math-block">$$ \begin{aligned}
&amp;\sum_{i=1}^n \mu^2(i) 
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \sum_{e|d} \mu(e)\mu^2\left(\frac de\right) \qquad &amp;(\mu^2 = \mu^2 * \mu * \text I)
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \sum_{e|q} \mu(pe)\mu^2\left(\frac {p^2q}{pe}\right) \qquad &amp;(令\ d = p^2 q, \ (p, q) = 1)
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \sum_{e|q} \mu(p)\mu(e)\mu^2\left(p\right)\mu^2\left(\frac {q}{e}\right)
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \mu^3(p) \sum_{e|q} \mu(e)\mu^2\left(\frac {q}{e}\right)
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \mu(p) \sum_{e|q} \mu(e) \qquad &amp; (有值的\ q\ 一定无平方因子)
\\ = &amp;  \sum_{i=1}^n \sum_{d|i} \mu(p) [q = 1]
\\ = &amp;  \sum_{i=1}^n \sum_{p^2|i} \mu(p)
\\ = &amp;  \sum_{p = 1}^{\left\lfloor\sqrt n\right\rfloor } \mu(p)\left\lfloor\frac n{p^2} \right\rfloor 
\end{aligned} $$</div></p>
<p><span class="markdown-them-math-inline">$1\to 2$</span> 中有贡献的 <span class="markdown-them-math-inline">$d$</span> 一定满足不存在 <span class="markdown-them-math-inline">$p^{2k + 1}$</span> 的质因子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 <span class="markdown-them-math-inline">$k$</span> 是正整数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p$</span> 是质数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
证明可以考虑 <span class="markdown-them-math-inline">$\mu(e)\mu^2\left(\frac de\right)$</span> 的取值需要非 <span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这也自然能导出对 <span class="markdown-them-math-inline">$q$</span> 的因子划分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这部分的复杂度是 <span class="markdown-them-math-inline">$O(\sqrt n)$</span> 的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>加上求质数个数的复杂度是亚线性的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>可过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://loj.ac/s/1654830">Submission</a>.</p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/08/06/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%9D%82%E8%AE%BA/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          生成函数杂论
        
      </div>
    </a>
  
  
    <a href="/2024/08/05/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E6%89%A9%E5%85%85%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%9D%E8%AF%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          概率密度扩充状态的一个尝试
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      Copyright &copy; 2024 joke3579<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="/mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->

  </div>
</body>
</html>